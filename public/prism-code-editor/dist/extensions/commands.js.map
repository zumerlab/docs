{"version":3,"file":"commands.js","sources":["../../src/extensions/commands.ts"],"sourcesContent":["/** @module commands */\r\n\r\nimport { InputSelection, BasicExtension, PrismEditor } from \"../index.js\"\r\nimport { isMac, preventDefault, languageMap, addTextareaListener } from \"../core.js\"\r\nimport {\r\n\tgetLanguage,\r\n\tinsertText,\r\n\tgetLineBefore,\r\n\tgetLines,\r\n\tregexEscape,\r\n\tgetModifierCode,\r\n\tprevSelection,\r\n} from \"../utils/index.js\"\r\nimport { getLineEnd, getLineStart, getStyleValue } from \"../utils/local.js\"\r\n\r\nlet ignoreTab = false\r\nconst clipboard = navigator.clipboard\r\nconst mod = isMac ? 4 : 2\r\n/**\r\n * Sets whether editors should ignore tab or use it for indentation.\r\n * Users can always toggle this using Ctrl+M / Ctrl+Shift+M (Mac).\r\n */\r\nconst setIgnoreTab = (newState: boolean) => (ignoreTab = newState)\r\nconst whitespaceEnd = (str: string) => str.search(/\\S|$/)\r\n\r\n/**\r\n * Extension that will add automatic indentation, closing of brackets,\r\n * quotes and tags along with the following commands:\r\n *\r\n * - Alt+ArrowUp/Down: Move line up/down\r\n * - Ctrl+ArrowUp/Down (Not on MacOS): Scroll up/down 1 line\r\n * - Shift+Alt+ArrowUp/Down: Copy line up/down\r\n * - Ctrl+Enter (Cmd+Enter on MacOS): Insert blank line\r\n * - Ctrl+[ (Cmd+[ on MacOS): Outdent line\r\n * - Ctrl+] (Cmd+] on MacOS): Indent line\r\n * - Shift+Ctrl+K (Shift+Cmd + K on MacOS): Delete line\r\n * - Ctrl+/ (Cmd+/ on MacOS): Toggle comment\r\n * - Shift+Alt+A: Toggle block comment\r\n * - Ctrl+M (Ctrl+Shift+M on MacOS): Toggle Tab capturing\r\n * \r\n * The shortcuts for the commands are not easily customizable. If you want to customize\r\n * them, you can copy the {@link https://github.com/FIameCaster/prism-code-editor/blob/main/package/src/extensions/commands.ts|source}\r\n * and change the conditions.\r\n *\r\n * @param selfClosePairs Pairs of self-closing brackets and quotes.\r\n * Must be an array of strings with 2 characters each.\r\n * Defaults to `['\"\"', \"''\", '``', '()', '[]', '{}']`.\r\n * @param selfCloseRegex Regex controlling whether or not a bracket/quote should\r\n * automatically close based on the character before and after the cursor.\r\n * Defaults to ``/([^$\\w'\"`][\"'`]|.[[({])[.,:;\\])}>\\s]|.[[({]`/s``.\r\n */\r\nconst defaultCommands =\r\n\t(\r\n\t\tselfClosePairs = ['\"\"', \"''\", \"``\", \"()\", \"[]\", \"{}\"],\r\n\t\tselfCloseRegex = /([^$\\w'\"`][\"'`]|.[[({])[.,:;\\])}>\\s]|.[[({]`/s,\r\n\t): BasicExtension =>\r\n\t(editor, options) => {\r\n\t\tlet prevCopy: string\r\n\t\tconst { keyCommandMap, inputCommandMap, getSelection, scrollContainer } = editor\r\n\r\n\t\tconst getIndent = ({ insertSpaces = true, tabSize } = options) =>\r\n\t\t\t[insertSpaces ? \" \" : \"\\t\", insertSpaces ? tabSize || 2 : 1] as const\r\n\r\n\t\tconst scroll = () => !options.readOnly && !editor.extensions.cursor?.scrollIntoView()\r\n\r\n\t\t/**\r\n\t\t * Automatically closes quotes and brackets if text is selected,\r\n\t\t * or if the character before and after the cursor matches a regex\r\n\t\t * @param wrapOnly If true, the character will only be closed if text is selected.\r\n\t\t */\r\n\t\tconst selfClose = (\r\n\t\t\t[start, end]: InputSelection,\r\n\t\t\t[open, close]: string,\r\n\t\t\tvalue: string,\r\n\t\t\twrapOnly?: boolean,\r\n\t\t) =>\r\n\t\t\t(start < end ||\r\n\t\t\t\t(!wrapOnly && selfCloseRegex.test((value[end - 1] || \" \") + open + (value[end] || \" \")))) &&\r\n\t\t\t!insertText(editor, open + value.slice(start, end) + close, null, null, start + 1, end + 1)!\r\n\r\n\t\tconst skipIfEqual = ([start, end]: InputSelection, char: string, value: string) =>\r\n\t\t\tstart == end && value[end] == char && !editor.setSelection(start + 1)!\r\n\r\n\t\t/**\r\n\t\t * Inserts slightly altered lines while keeping the same selection.\r\n\t\t * Used when toggling comments and indenting.\r\n\t\t */\r\n\t\tconst insertLines = (\r\n\t\t\told: string[],\r\n\t\t\tnewL: string[],\r\n\t\t\tstart: number,\r\n\t\t\tend: number,\r\n\t\t\tselectionStart: number,\r\n\t\t\tselectionEnd: number,\r\n\t\t) => {\r\n\t\t\tlet newLines = newL.join(\"\\n\")\r\n\t\t\tif (newLines != old.join(\"\\n\")) {\r\n\t\t\t\tconst last = old.length - 1\r\n\t\t\t\tconst lastLine = newL[last]\r\n\t\t\t\tconst oldLastLine = old[last]\r\n\t\t\t\tconst lastDiff = oldLastLine.length - lastLine.length\r\n\t\t\t\tconst firstDiff = newL[0].length - old[0].length\r\n\t\t\t\tconst firstInsersion = start + whitespaceEnd((firstDiff < 0 ? newL : old)[0])\r\n\t\t\t\tconst lastInsersion =\r\n\t\t\t\t\tend - oldLastLine.length + whitespaceEnd(lastDiff > 0 ? lastLine : oldLastLine)\r\n\t\t\t\tconst offset = start - end + newLines.length + lastDiff\r\n\t\t\t\tconst newCursorStart =\r\n\t\t\t\t\tfirstInsersion > selectionStart\r\n\t\t\t\t\t\t? selectionStart\r\n\t\t\t\t\t\t: Math.max(firstInsersion, selectionStart + firstDiff)\r\n\t\t\t\tconst newCursorEnd = selectionEnd + start - end + newLines.length\r\n\t\t\t\tinsertText(\r\n\t\t\t\t\teditor,\r\n\t\t\t\t\tnewLines,\r\n\t\t\t\t\tstart,\r\n\t\t\t\t\tend,\r\n\t\t\t\t\tnewCursorStart,\r\n\t\t\t\t\tselectionEnd < lastInsersion\r\n\t\t\t\t\t\t? newCursorEnd + lastDiff\r\n\t\t\t\t\t\t: Math.max(lastInsersion + offset, newCursorEnd),\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst indent = (\r\n\t\t\toutdent: boolean,\r\n\t\t\tlines: string[],\r\n\t\t\tstart1: number,\r\n\t\t\tend1: number,\r\n\t\t\tstart: number,\r\n\t\t\tend: number,\r\n\t\t\tindentChar: string,\r\n\t\t\ttabSize: number,\r\n\t\t) => {\r\n\t\t\tinsertLines(\r\n\t\t\t\tlines,\r\n\t\t\t\tlines.map(\r\n\t\t\t\t\toutdent\r\n\t\t\t\t\t\t? str => str.slice(whitespaceEnd(str) ? tabSize - (whitespaceEnd(str) % tabSize) : 0)\r\n\t\t\t\t\t\t: str => str && indentChar.repeat(tabSize - (whitespaceEnd(str) % tabSize)) + str,\r\n\t\t\t\t),\r\n\t\t\t\tstart1,\r\n\t\t\t\tend1,\r\n\t\t\t\tstart,\r\n\t\t\t\tend,\r\n\t\t\t)\r\n\t\t}\r\n\r\n\t\tinputCommandMap[\"<\"] = (_e, selection, value) => selfClose(selection, \"<>\", value, true)\r\n\r\n\t\tselfClosePairs.forEach(([open, close]) => {\r\n\t\t\tconst isQuote = open == close\r\n\t\t\tinputCommandMap[open] = (_e, selection, value) =>\r\n\t\t\t\t((isQuote && skipIfEqual(selection, close, value)) ||\r\n\t\t\t\t\tselfClose(selection, open + close, value)) &&\r\n\t\t\t\tscroll()\r\n\t\t\tif (!isQuote)\r\n\t\t\t\tinputCommandMap[close] = (_e, selection, value) =>\r\n\t\t\t\t\tskipIfEqual(selection, close, value) && scroll()\r\n\t\t})\r\n\r\n\t\tinputCommandMap[\">\"] = (e, selection, value) => {\r\n\t\t\tconst closingTag = languageMap[getLanguage(editor)]?.autoCloseTags?.(selection, value, editor)\r\n\t\t\tif (closingTag) {\r\n\t\t\t\tinsertText(editor, \">\" + closingTag, null, null, selection[0] + 1)\r\n\t\t\t\tpreventDefault(e)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tkeyCommandMap.Tab = (e, [start, end], value) => {\r\n\t\t\tif (ignoreTab || options.readOnly || getModifierCode(e) & 6) return\r\n\t\t\tconst [indentChar, tabSize] = getIndent(options)\r\n\t\t\tconst shiftKey = e.shiftKey\r\n\t\t\tconst [lines, start1, end1] = getLines(value, start, end)\r\n\t\t\tif (start < end || shiftKey) {\r\n\t\t\t\tindent(shiftKey, lines, start1, end1, start, end, indentChar, tabSize)\r\n\t\t\t} else insertText(editor, indentChar.repeat(tabSize - ((start - start1) % tabSize)))\r\n\t\t\treturn scroll()\r\n\t\t}\r\n\r\n\t\tkeyCommandMap.Enter = (e, selection, value) => {\r\n\t\t\tconst code = getModifierCode(e) & 7\r\n\t\t\tif (!code || code == mod) {\r\n\t\t\t\tif (code) selection[0] = selection[1] = getLines(value, selection[1])[2]\r\n\t\t\t\tconst [indentChar, tabSize] = getIndent()\r\n\t\t\t\tconst [start, end] = selection\r\n\t\t\t\tconst autoIndent = languageMap[getLanguage(editor)]?.autoIndent\r\n\t\t\t\tconst indenationCount =\r\n\t\t\t\t\tMath.floor(whitespaceEnd(getLineBefore(value, start)) / tabSize) * tabSize\r\n\t\t\t\tconst extraIndent = autoIndent?.[0]?.(selection, value, editor) ? tabSize : 0\r\n\t\t\t\tconst extraLine = autoIndent?.[1]?.(selection, value, editor)\r\n\t\t\t\tconst newText =\r\n\t\t\t\t\t\"\\n\" +\r\n\t\t\t\t\tindentChar.repeat(indenationCount + extraIndent) +\r\n\t\t\t\t\t(extraLine ? \"\\n\" + indentChar.repeat(indenationCount) : \"\")\r\n\r\n\t\t\t\tif (newText[1] || value[end]) {\r\n\t\t\t\t\tinsertText(editor, newText, start, end, start + indenationCount + extraIndent + 1)\r\n\t\t\t\t\treturn scroll()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tkeyCommandMap.Backspace = (_e, [start, end], value) => {\r\n\t\t\tif (start == end) {\r\n\t\t\t\tconst line = getLineBefore(value, start)\r\n\t\t\t\tconst tabSize = options.tabSize || 2\r\n\t\t\t\tconst isPair = selfClosePairs.includes(value.slice(start - 1, start + 1))\r\n\t\t\t\tconst indenationCount = /[^ ]/.test(line) ? 0 : ((line.length - 1) % tabSize) + 1\r\n\r\n\t\t\t\tif (isPair || indenationCount > 1) {\r\n\t\t\t\t\tinsertText(editor, \"\", start - (isPair ? 1 : indenationCount), start + <any>isPair)\r\n\t\t\t\t\treturn scroll()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < 2; i++) {\r\n\t\t\tkeyCommandMap[i ? \"ArrowDown\" : \"ArrowUp\"] = (e, [start, end], value) => {\r\n\t\t\t\tconst code = getModifierCode(e)\r\n\r\n\t\t\t\tif (code == 1) {\r\n\t\t\t\t\t// Moving lines\r\n\t\t\t\t\tconst newStart = i ? start : getLineStart(value, start) - 1\r\n\t\t\t\t\tconst newEnd = i ? value.indexOf(\"\\n\", end) + 1 : end\r\n\t\t\t\t\tif (newStart > -1 && newEnd > 0) {\r\n\t\t\t\t\t\tconst [lines, start1, end1] = getLines(value, newStart, newEnd)\r\n\t\t\t\t\t\tconst line = lines[i ? \"pop\" : \"shift\"]()!\r\n\t\t\t\t\t\tconst offset = (line.length + 1) * (i ? 1 : -1)\r\n\r\n\t\t\t\t\t\tlines[i ? \"unshift\" : \"push\"](line)\r\n\t\t\t\t\t\tinsertText(editor, lines.join(\"\\n\"), start1, end1, start + offset, end + offset)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn scroll()\r\n\t\t\t\t} else if (code == 9) {\r\n\t\t\t\t\t// Copying lines\r\n\t\t\t\t\tconst [lines, start1, end1] = getLines(value, start, end)\r\n\t\t\t\t\tconst str = lines.join(\"\\n\")\r\n\t\t\t\t\tconst offset = i ? str.length + 1 : 0\r\n\t\t\t\t\tinsertText(editor, str + \"\\n\" + str, start1, end1, start + offset, end + offset)\r\n\t\t\t\t\treturn scroll()\r\n\t\t\t\t} else if (code == 2 && !isMac) {\r\n\t\t\t\t\tscrollContainer.scrollBy(0, getStyleValue(scrollContainer, \"lineHeight\") * (i ? 1 : -1))\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\taddTextareaListener(editor, \"keydown\", e => {\r\n\t\t\tconst code = getModifierCode(e)\r\n\t\t\tconst keyCode = e.keyCode\r\n\t\t\tconst [start, end, dir] = getSelection()\r\n\r\n\t\t\tif (code == mod && (keyCode == 221 || keyCode == 219)) {\r\n\t\t\t\tindent(keyCode == 219, ...getLines(editor.value, start, end), start, end, ...getIndent())\r\n\t\t\t\tscroll()\r\n\t\t\t\tpreventDefault(e)\r\n\t\t\t} else if (code == (isMac ? 0b1010 : 0b0010) && keyCode == 77) {\r\n\t\t\t\tsetIgnoreTab(!ignoreTab)\r\n\t\t\t\tpreventDefault(e)\r\n\t\t\t} else if ((keyCode == 191 && code == mod) || (keyCode == 65 && code == 9)) {\r\n\t\t\t\tconst value = editor.value\r\n\t\t\t\tconst isBlock = code == 9\r\n\t\t\t\tconst position = isBlock ? start : getLineStart(value, start)\r\n\t\t\t\tconst language = languageMap[getLanguage(editor, position)] || {}\r\n\t\t\t\tconst { line, block } =\r\n\t\t\t\t\tlanguage.getComments?.(editor, position, value) || language.comments || {}\r\n\t\t\t\tconst [lines, start1, end1] = getLines(value, start, end)\r\n\t\t\t\tconst last = lines.length - 1\r\n\r\n\t\t\t\tif (isBlock) {\r\n\t\t\t\t\tif (block) {\r\n\t\t\t\t\t\tconst [open, close] = block\r\n\t\t\t\t\t\tconst text = value.slice(start, end)\r\n\t\t\t\t\t\tconst pos = value.slice(0, start).search(regexEscape(open) + \" ?$\")\r\n\t\t\t\t\t\tconst matches = RegExp(\"^ ?\" + regexEscape(close)).test(value.slice(end))\r\n\r\n\t\t\t\t\t\tif (pos + 1 && matches)\r\n\t\t\t\t\t\t\tinsertText(\r\n\t\t\t\t\t\t\t\teditor,\r\n\t\t\t\t\t\t\t\ttext,\r\n\t\t\t\t\t\t\t\tpos,\r\n\t\t\t\t\t\t\t\tend + +(value[end] == \" \") + close.length,\r\n\t\t\t\t\t\t\t\tpos,\r\n\t\t\t\t\t\t\t\tpos + end - start,\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tinsertText(\r\n\t\t\t\t\t\t\t\teditor,\r\n\t\t\t\t\t\t\t\t`${open} ${text} ${close}`,\r\n\t\t\t\t\t\t\t\tstart,\r\n\t\t\t\t\t\t\t\tend,\r\n\t\t\t\t\t\t\t\tstart + open.length + 1,\r\n\t\t\t\t\t\t\t\tend + open.length + 1,\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\tscroll()\r\n\t\t\t\t\t\tpreventDefault(e)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (line) {\r\n\t\t\t\t\t\tconst escaped = regexEscape(line)\r\n\t\t\t\t\t\tconst regex = RegExp(`^\\\\s*(${escaped} ?|$)`)\r\n\t\t\t\t\t\tconst regex2 = RegExp(escaped + \" ?\")\r\n\t\t\t\t\t\tconst allWhiteSpace = !/\\S/.test(value.slice(start1, end1))\r\n\t\t\t\t\t\tconst newLines = lines.map(\r\n\t\t\t\t\t\t\tlines.every(line => regex.test(line)) && !allWhiteSpace\r\n\t\t\t\t\t\t\t\t? str => str.replace(regex2, \"\")\r\n\t\t\t\t\t\t\t\t: str =>\r\n\t\t\t\t\t\t\t\t\t\tallWhiteSpace || /\\S/.test(str) ? str.replace(/^\\s*/, `$&${line} `) : str,\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\tinsertLines(lines, newLines, start1, end1, start, end)\r\n\t\t\t\t\t\tscroll()\r\n\t\t\t\t\t\tpreventDefault(e)\r\n\t\t\t\t\t} else if (block) {\r\n\t\t\t\t\t\tconst [open, close] = block\r\n\t\t\t\t\t\tconst insertionPoint = whitespaceEnd(lines[0])\r\n\t\t\t\t\t\tconst hasComment =\r\n\t\t\t\t\t\t\tlines[0].startsWith(open, insertionPoint) && lines[last].endsWith(close)\r\n\t\t\t\t\t\tconst newLines = lines.slice()\r\n\r\n\t\t\t\t\t\tnewLines[0] = lines[0].replace(\r\n\t\t\t\t\t\t\thasComment ? RegExp(regexEscape(open) + \" ?\") : /(?=\\S)|$/,\r\n\t\t\t\t\t\t\thasComment ? \"\" : open + \" \",\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\tlet diff = newLines[0].length - lines[0].length\r\n\t\t\t\t\t\tnewLines[last] = hasComment\r\n\t\t\t\t\t\t\t? newLines[last].replace(RegExp(`( ?${regexEscape(close)})?$`), \"\")\r\n\t\t\t\t\t\t\t: newLines[last] + \" \" + close\r\n\r\n\t\t\t\t\t\tlet newText = newLines.join(\"\\n\")\r\n\t\t\t\t\t\tlet firstInsersion = insertionPoint + start1\r\n\t\t\t\t\t\tlet newStart = firstInsersion > start ? start : Math.max(start + diff, firstInsersion)\r\n\t\t\t\t\t\tlet newEnd =\r\n\t\t\t\t\t\t\tfirstInsersion > end - <any>(start != end)\r\n\t\t\t\t\t\t\t\t? end\r\n\t\t\t\t\t\t\t\t: Math.min(Math.max(firstInsersion, end + diff), start1 + newText.length)\r\n\t\t\t\t\t\tinsertText(editor, newText, start1, end1, newStart, Math.max(newStart, newEnd))\r\n\t\t\t\t\t\tscroll()\r\n\t\t\t\t\t\tpreventDefault(e)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (code == 8 + mod && keyCode == 75) {\r\n\t\t\t\tconst value = editor.value\r\n\t\t\t\tconst [lines, start1, end1] = getLines(value, start, end)\r\n\t\t\t\tconst column = dir > \"f\" ? end - end1 + lines.pop()!.length : start - start1\r\n\t\t\t\tconst newLineLen = getLineEnd(value, end1 + 1) - end1 - 1\r\n\t\t\t\tinsertText(\r\n\t\t\t\t\teditor,\r\n\t\t\t\t\t\"\",\r\n\t\t\t\t\tstart1 - <any>!!start1,\r\n\t\t\t\t\tend1 + <any>!start1,\r\n\t\t\t\t\tstart1 + Math.min(column, newLineLen),\r\n\t\t\t\t)\r\n\t\t\t\tscroll()\r\n\t\t\t\tpreventDefault(e)\r\n\t\t\t}\r\n\t\t})\r\n\t\t;([\"copy\", \"cut\", \"paste\"] as const).forEach(type =>\r\n\t\t\taddTextareaListener(editor, type, e => {\r\n\t\t\t\tconst [start, end] = getSelection()\r\n\t\t\t\tif (start == end && clipboard) {\r\n\t\t\t\t\tconst [[line], start1, end1] = getLines(editor.value, start, end)\r\n\t\t\t\t\tif (type == \"paste\") {\r\n\t\t\t\t\t\tif (e.clipboardData!.getData(\"text/plain\") == prevCopy) {\r\n\t\t\t\t\t\t\tinsertText(editor, prevCopy + \"\\n\", start1, start1, start + prevCopy.length + 1)\r\n\t\t\t\t\t\t\tscroll()\r\n\t\t\t\t\t\t\tpreventDefault(e)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tclipboard.writeText((prevCopy = line))\r\n\t\t\t\t\t\tif (type == \"cut\") insertText(editor, \"\", start1, end1 + 1), scroll()\r\n\t\t\t\t\t\tpreventDefault(e)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}),\r\n\t\t)\r\n\t}\r\n\r\nexport interface EditHistory extends BasicExtension {\r\n\t/** Clears the history stack. Probably necessary after changing the value of the editor. */\r\n\tclear(): void\r\n\t/**\r\n\t * Sets the active entry relative to the current entry.\r\n\t *\r\n\t * @param offset The position you want to move to relative to the current entry.\r\n\t *\r\n\t * `EditHistory.go(-1)` would be equivalent to an undo while `EditHistory.go(1)` would\r\n\t * be equivalent to a redo.\r\n\t *\r\n\t * If there's no entry at the specified offset, the call does nothing.\r\n\t */\r\n\tgo(offset: number): void\r\n\t/**\r\n\t * Returns whether or not there exists a history entry at the specified offset relative\r\n\t * to the current entry.\r\n\t *\r\n\t * This method can be used to determine whether a call to {@link EditHistory.go} with the\r\n\t * same offset will succeed or do nothing.\r\n\t */\r\n\thas(offset: number): boolean\r\n}\r\n\r\n/**\r\n * History extension that overrides the undo/redo behavior of the browser.\r\n *\r\n * Without this extension, the browser's native undo/redo is used, which can be sufficient\r\n * in some cases.\r\n *\r\n * It should be noted that the history stack is not automatically cleared when the editors\r\n * value is changed programmatically using `editor.setOptions` Instead you can clear the\r\n * stack any time using {@link EditHistory.clear}.\r\n *\r\n * Once added to an editor, this extension can be accessed from `editor.extensions.history`.\r\n *\r\n * If you want to create a new editor with different extensions while keeping the undo/redo\r\n * history of an old editor, you can! Just add the old editor's history extension instance\r\n * to the new editor. Keep in mind that this will fully break the undo/redo behavior of the\r\n * old editor.\r\n *\r\n * @param historyLimit The maximum size of the history stack. Defaults to 999.\r\n */\r\nconst editHistory = (historyLimit = 999) => {\r\n\tlet sp = 0\r\n\tlet currentEditor: PrismEditor\r\n\tlet allowMerge: boolean\r\n\tlet isTyping = false\r\n\tlet prevInputType: string\r\n\tlet prevData: string | null\r\n\tlet prevTime: number\r\n\tlet isMerge: boolean\r\n\tlet textarea: HTMLTextAreaElement\r\n\tlet getSelection: PrismEditor[\"getSelection\"]\r\n\r\n\tconst stack: [string, InputSelection, InputSelection][] = []\r\n\tconst update = (index: number) => {\r\n\t\tif (index >= historyLimit) {\r\n\t\t\tindex--\r\n\t\t\tstack.shift()\r\n\t\t}\r\n\t\tstack.splice((sp = index), historyLimit, [currentEditor.value, getSelection(), getSelection()])\r\n\t}\r\n\tconst setEditorState = (index: number) => {\r\n\t\tif (stack[index]) {\r\n\t\t\ttextarea.value = stack[index][0]\r\n\t\t\ttextarea.setSelectionRange(...stack[index][index < sp ? 2 : 1])\r\n\t\t\tcurrentEditor.update()\r\n\t\t\tcurrentEditor.extensions.cursor?.scrollIntoView()\r\n\t\t\tsp = index\r\n\t\t\tallowMerge = false\r\n\t\t}\r\n\t}\r\n\r\n\tconst self: EditHistory = (editor, options) => {\r\n\t\teditor.extensions.history = self\r\n\t\tcurrentEditor = editor\r\n\t\tgetSelection = editor.getSelection\r\n\t\ttextarea || update(0)\r\n\t\ttextarea = editor.textarea\r\n\r\n\t\teditor.addListener(\"selectionChange\", () => {\r\n\t\t\tallowMerge = isTyping\r\n\t\t\tisTyping = false\r\n\t\t})\r\n\r\n\t\taddTextareaListener(editor, \"beforeinput\", e => {\r\n\t\t\tlet data = e.data\r\n\t\t\tlet inputType = e.inputType\r\n\t\t\tlet time = e.timeStamp\r\n\r\n\t\t\tif (/history/.test(inputType)) {\r\n\t\t\t\tsetEditorState(sp + (inputType[7] == \"U\" ? -1 : 1))\r\n\t\t\t\tpreventDefault(e)\r\n\t\t\t} else if (\r\n\t\t\t\t!(isMerge =\r\n\t\t\t\t\tallowMerge &&\r\n\t\t\t\t\t(prevInputType == inputType || (time - prevTime < 99 && inputType.slice(-4) == \"Drop\")) &&\r\n\t\t\t\t\t!prevSelection &&\r\n\t\t\t\t\t(data != \" \" || prevData == data))\r\n\t\t\t) {\r\n\t\t\t\tstack[sp][2] = prevSelection || getSelection()\r\n\t\t\t}\r\n\t\t\tisTyping = true\r\n\t\t\tprevData = data\r\n\t\t\tprevTime = time\r\n\t\t\tprevInputType = inputType\r\n\t\t})\r\n\t\taddTextareaListener(editor, \"input\", () => update(sp + <any>!isMerge))\r\n\t\taddTextareaListener(editor, \"keydown\", e => {\r\n\t\t\tif (!options.readOnly) {\r\n\t\t\t\tconst code = getModifierCode(e)\r\n\t\t\t\tconst keyCode = e.keyCode\r\n\t\t\t\tconst isUndo = code == mod && keyCode == 90\r\n\t\t\t\tconst isRedo =\r\n\t\t\t\t\t(code == mod + 8 && keyCode == 90) || (!isMac && code == mod && keyCode == 89)\r\n\t\t\t\tif (isUndo) {\r\n\t\t\t\t\tsetEditorState(sp - 1)\r\n\t\t\t\t\tpreventDefault(e)\r\n\t\t\t\t} else if (isRedo) {\r\n\t\t\t\t\tsetEditorState(sp + 1)\r\n\t\t\t\t\tpreventDefault(e)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tself.clear = () => {\r\n\t\tupdate(0)\r\n\t\tallowMerge = false\r\n\t}\r\n\r\n\tself.has = offset => sp + offset in stack\r\n\tself.go = offset => setEditorState(sp + offset)\r\n\r\n\treturn self\r\n}\r\n\r\nexport { defaultCommands, setIgnoreTab, ignoreTab, editHistory }\r\n"],"names":["line"],"mappings":";;;AAeA,IAAI,YAAY;AAChB,MAAM,YAAY,UAAU;AAC5B,MAAM,MAAM,QAAQ,IAAI;AAKlB,MAAA,eAAe,CAAC,aAAuB,YAAY;AACzD,MAAM,gBAAgB,CAAC,QAAgB,IAAI,OAAO,MAAM;AA4BxD,MAAM,kBACL,CACC,iBAAiB,CAAC,MAAM,MAAM,MAAM,MAAM,MAAM,IAAI,GACpD,iBAAiB,oDAElB,CAAC,QAAQ,YAAY;AAChB,MAAA;AACJ,QAAM,EAAE,eAAe,iBAAiB,cAAc,oBAAoB;AAE1E,QAAM,YAAY,CAAC,EAAE,eAAe,MAAM,QAAQ,IAAI,YACrD,CAAC,eAAe,MAAM,KAAM,eAAe,WAAW,IAAI,CAAC;AAEtD,QAAA,SAAS,MAAM,CAAC,QAAQ,YAAY,CAAC,OAAO,WAAW,QAAQ;AAO/D,QAAA,YAAY,CACjB,CAAC,OAAO,GAAG,GACX,CAAC,MAAM,KAAK,GACZ,OACA,cAEC,QAAQ,OACP,CAAC,YAAY,eAAe,MAAM,MAAM,MAAM,CAAC,KAAK,OAAO,QAAQ,MAAM,GAAG,KAAK,IAAI,MACvF,CAAC,WAAW,QAAQ,OAAO,MAAM,MAAM,OAAO,GAAG,IAAI,OAAO,MAAM,MAAM,QAAQ,GAAG,MAAM,CAAC;AAE3F,QAAM,cAAc,CAAC,CAAC,OAAO,GAAG,GAAmB,MAAc,UAChE,SAAS,OAAO,MAAM,GAAG,KAAK,QAAQ,CAAC,OAAO,aAAa,QAAQ,CAAC;AAMrE,QAAM,cAAc,CACnB,KACA,MACA,OACA,KACA,gBACA,iBACI;AACA,QAAA,WAAW,KAAK,KAAK,IAAI;AAC7B,QAAI,YAAY,IAAI,KAAK,IAAI,GAAG;AACzB,YAAA,OAAO,IAAI,SAAS;AACpB,YAAA,WAAW,KAAK,IAAI;AACpB,YAAA,cAAc,IAAI,IAAI;AACtB,YAAA,WAAW,YAAY,SAAS,SAAS;AAC/C,YAAM,YAAY,KAAK,CAAC,EAAE,SAAS,IAAI,CAAC,EAAE;AACpC,YAAA,iBAAiB,QAAQ,eAAe,YAAY,IAAI,OAAO,KAAK,CAAC,CAAC;AACtE,YAAA,gBACL,MAAM,YAAY,SAAS,cAAc,WAAW,IAAI,WAAW,WAAW;AAC/E,YAAM,SAAS,QAAQ,MAAM,SAAS,SAAS;AACzC,YAAA,iBACL,iBAAiB,iBACd,iBACA,KAAK,IAAI,gBAAgB,iBAAiB,SAAS;AACvD,YAAM,eAAe,eAAe,QAAQ,MAAM,SAAS;AAC3D;AAAA,QACC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,eAAe,gBACZ,eAAe,WACf,KAAK,IAAI,gBAAgB,QAAQ,YAAY;AAAA,MAAA;AAAA,IAElD;AAAA,EAAA;AAGK,QAAA,SAAS,CACd,SACA,OACA,QACA,MACA,OACA,KACA,YACA,YACI;AACJ;AAAA,MACC;AAAA,MACA,MAAM;AAAA,QACL,UACG,SAAO,IAAI,MAAM,cAAc,GAAG,IAAI,UAAW,cAAc,GAAG,IAAI,UAAW,CAAC,IAClF,CAAO,QAAA,OAAO,WAAW,OAAO,UAAW,cAAc,GAAG,IAAI,OAAQ,IAAI;AAAA,MAChF;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAAA,EACD;AAGe,kBAAA,GAAG,IAAI,CAAC,IAAI,WAAW,UAAU,UAAU,WAAW,MAAM,OAAO,IAAI;AAEvF,iBAAe,QAAQ,CAAC,CAAC,MAAM,KAAK,MAAM;AACzC,UAAM,UAAU,QAAQ;AACxB,oBAAgB,IAAI,IAAI,CAAC,IAAI,WAAW,WACrC,WAAW,YAAY,WAAW,OAAO,KAAK,KAC/C,UAAU,WAAW,OAAO,OAAO,KAAK,MACzC;AACD,QAAI,CAAC;AACY,sBAAA,KAAK,IAAI,CAAC,IAAI,WAAW,UACxC,YAAY,WAAW,OAAO,KAAK,KAAK,OAAO;AAAA,EAAA,CACjD;AAED,kBAAgB,GAAG,IAAI,CAAC,GAAG,WAAW,UAAU;AACzC,UAAA,aAAa,YAAY,YAAY,MAAM,CAAC,GAAG,gBAAgB,WAAW,OAAO,MAAM;AAC7F,QAAI,YAAY;AACJ,iBAAA,QAAQ,MAAM,YAAY,MAAM,MAAM,UAAU,CAAC,IAAI,CAAC;AACjE,qBAAe,CAAC;AAAA,IACjB;AAAA,EAAA;AAGD,gBAAc,MAAM,CAAC,GAAG,CAAC,OAAO,GAAG,GAAG,UAAU;AAC/C,QAAI,aAAa,QAAQ,YAAY,gBAAgB,CAAC,IAAI;AAAG;AAC7D,UAAM,CAAC,YAAY,OAAO,IAAI,UAAU,OAAO;AAC/C,UAAM,WAAW,EAAE;AACb,UAAA,CAAC,OAAO,QAAQ,IAAI,IAAI,SAAS,OAAO,OAAO,GAAG;AACpD,QAAA,QAAQ,OAAO,UAAU;AAC5B,aAAO,UAAU,OAAO,QAAQ,MAAM,OAAO,KAAK,YAAY,OAAO;AAAA,IACtE;AAAO,iBAAW,QAAQ,WAAW,OAAO,WAAY,QAAQ,UAAU,OAAQ,CAAC;AACnF,WAAO,OAAO;AAAA,EAAA;AAGf,gBAAc,QAAQ,CAAC,GAAG,WAAW,UAAU;AACxC,UAAA,OAAO,gBAAgB,CAAC,IAAI;AAC9B,QAAA,CAAC,QAAQ,QAAQ,KAAK;AACrB,UAAA;AAAgB,kBAAA,CAAC,IAAI,UAAU,CAAC,IAAI,SAAS,OAAO,UAAU,CAAC,CAAC,EAAE,CAAC;AACvE,YAAM,CAAC,YAAY,OAAO,IAAI,UAAU;AAClC,YAAA,CAAC,OAAO,GAAG,IAAI;AACrB,YAAM,aAAa,YAAY,YAAY,MAAM,CAAC,GAAG;AAC/C,YAAA,kBACL,KAAK,MAAM,cAAc,cAAc,OAAO,KAAK,CAAC,IAAI,OAAO,IAAI;AAC9D,YAAA,cAAc,aAAa,CAAC,IAAI,WAAW,OAAO,MAAM,IAAI,UAAU;AAC5E,YAAM,YAAY,aAAa,CAAC,IAAI,WAAW,OAAO,MAAM;AAC5D,YAAM,UACL,OACA,WAAW,OAAO,kBAAkB,WAAW,KAC9C,YAAY,OAAO,WAAW,OAAO,eAAe,IAAI;AAE1D,UAAI,QAAQ,CAAC,KAAK,MAAM,GAAG,GAAG;AAC7B,mBAAW,QAAQ,SAAS,OAAO,KAAK,QAAQ,kBAAkB,cAAc,CAAC;AACjF,eAAO,OAAO;AAAA,MACf;AAAA,IACD;AAAA,EAAA;AAGD,gBAAc,YAAY,CAAC,IAAI,CAAC,OAAO,GAAG,GAAG,UAAU;AACtD,QAAI,SAAS,KAAK;AACX,YAAA,OAAO,cAAc,OAAO,KAAK;AACjC,YAAA,UAAU,QAAQ,WAAW;AAC7B,YAAA,SAAS,eAAe,SAAS,MAAM,MAAM,QAAQ,GAAG,QAAQ,CAAC,CAAC;AAClE,YAAA,kBAAkB,OAAO,KAAK,IAAI,IAAI,KAAM,KAAK,SAAS,KAAK,UAAW;AAE5E,UAAA,UAAU,kBAAkB,GAAG;AAClC,mBAAW,QAAQ,IAAI,SAAS,SAAS,IAAI,kBAAkB,QAAa,MAAM;AAClF,eAAO,OAAO;AAAA,MACf;AAAA,IACD;AAAA,EAAA;AAGD,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACb,kBAAA,IAAI,cAAc,SAAS,IAAI,CAAC,GAAG,CAAC,OAAO,GAAG,GAAG,UAAU;AAClE,YAAA,OAAO,gBAAgB,CAAC;AAE9B,UAAI,QAAQ,GAAG;AAEd,cAAM,WAAW,IAAI,QAAQ,aAAa,OAAO,KAAK,IAAI;AAC1D,cAAM,SAAS,IAAI,MAAM,QAAQ,MAAM,GAAG,IAAI,IAAI;AAC9C,YAAA,WAAW,MAAM,SAAS,GAAG;AAC1B,gBAAA,CAAC,OAAO,QAAQ,IAAI,IAAI,SAAS,OAAO,UAAU,MAAM;AAC9D,gBAAM,OAAO,MAAM,IAAI,QAAQ,OAAO,EAAE;AACxC,gBAAM,UAAU,KAAK,SAAS,MAAM,IAAI,IAAI;AAE5C,gBAAM,IAAI,YAAY,MAAM,EAAE,IAAI;AACvB,qBAAA,QAAQ,MAAM,KAAK,IAAI,GAAG,QAAQ,MAAM,QAAQ,QAAQ,MAAM,MAAM;AAAA,QAChF;AACA,eAAO,OAAO;AAAA,MAAA,WACJ,QAAQ,GAAG;AAEf,cAAA,CAAC,OAAO,QAAQ,IAAI,IAAI,SAAS,OAAO,OAAO,GAAG;AAClD,cAAA,MAAM,MAAM,KAAK,IAAI;AAC3B,cAAM,SAAS,IAAI,IAAI,SAAS,IAAI;AACzB,mBAAA,QAAQ,MAAM,OAAO,KAAK,QAAQ,MAAM,QAAQ,QAAQ,MAAM,MAAM;AAC/E,eAAO,OAAO;AAAA,MACJ,WAAA,QAAQ,KAAK,CAAC,OAAO;AACf,wBAAA,SAAS,GAAG,cAAc,iBAAiB,YAAY,KAAK,IAAI,IAAI,GAAG;AAChF,eAAA;AAAA,MACR;AAAA,IAAA;AAAA,EAEF;AAEoB,sBAAA,QAAQ,WAAW,CAAK,MAAA;AACrC,UAAA,OAAO,gBAAgB,CAAC;AAC9B,UAAM,UAAU,EAAE;AAClB,UAAM,CAAC,OAAO,KAAK,GAAG,IAAI,aAAa;AAEvC,QAAI,QAAQ,QAAQ,WAAW,OAAO,WAAW,MAAM;AACtD,aAAO,WAAW,KAAK,GAAG,SAAS,OAAO,OAAO,OAAO,GAAG,GAAG,OAAO,KAAK,GAAG,UAAW,CAAA;AACjF;AACP,qBAAe,CAAC;AAAA,IAAA,WACN,SAAS,QAAQ,KAAS,MAAW,WAAW,IAAI;AAC9D,mBAAa,CAAC,SAAS;AACvB,qBAAe,CAAC;AAAA,IAAA,WACL,WAAW,OAAO,QAAQ,OAAS,WAAW,MAAM,QAAQ,GAAI;AAC3E,YAAM,QAAQ,OAAO;AACrB,YAAM,UAAU,QAAQ;AACxB,YAAM,WAAW,UAAU,QAAQ,aAAa,OAAO,KAAK;AAC5D,YAAM,WAAW,YAAY,YAAY,QAAQ,QAAQ,CAAC,KAAK;AAC/D,YAAM,EAAE,MAAM,MAAM,IACnB,SAAS,cAAc,QAAQ,UAAU,KAAK,KAAK,SAAS,YAAY,CAAA;AACnE,YAAA,CAAC,OAAO,QAAQ,IAAI,IAAI,SAAS,OAAO,OAAO,GAAG;AAClD,YAAA,OAAO,MAAM,SAAS;AAE5B,UAAI,SAAS;AACZ,YAAI,OAAO;AACJ,gBAAA,CAAC,MAAM,KAAK,IAAI;AACtB,gBAAM,OAAO,MAAM,MAAM,OAAO,GAAG;AAC7B,gBAAA,MAAM,MAAM,MAAM,GAAG,KAAK,EAAE,OAAO,YAAY,IAAI,IAAI,KAAK;AAC5D,gBAAA,UAAU,OAAO,QAAQ,YAAY,KAAK,CAAC,EAAE,KAAK,MAAM,MAAM,GAAG,CAAC;AAExE,cAAI,MAAM,KAAK;AACd;AAAA,cACC;AAAA,cACA;AAAA,cACA;AAAA,cACA,MAAM,EAAE,MAAM,GAAG,KAAK,OAAO,MAAM;AAAA,cACnC;AAAA,cACA,MAAM,MAAM;AAAA,YAAA;AAAA;AAGb;AAAA,cACC;AAAA,cACA,GAAG,IAAI,IAAI,IAAI,IAAI,KAAK;AAAA,cACxB;AAAA,cACA;AAAA,cACA,QAAQ,KAAK,SAAS;AAAA,cACtB,MAAM,KAAK,SAAS;AAAA,YAAA;AAEf;AACP,yBAAe,CAAC;AAAA,QACjB;AAAA,MAAA,OACM;AACN,YAAI,MAAM;AACH,gBAAA,UAAU,YAAY,IAAI;AAChC,gBAAM,QAAQ,OAAO,SAAS,OAAO,OAAO;AACtC,gBAAA,SAAS,OAAO,UAAU,IAAI;AAC9B,gBAAA,gBAAgB,CAAC,KAAK,KAAK,MAAM,MAAM,QAAQ,IAAI,CAAC;AAC1D,gBAAM,WAAW,MAAM;AAAA,YACtB,MAAM,MAAM,CAAAA,UAAQ,MAAM,KAAKA,KAAI,CAAC,KAAK,CAAC,gBACvC,CAAA,QAAO,IAAI,QAAQ,QAAQ,EAAE,IAC7B,CAAA,QACA,iBAAiB,KAAK,KAAK,GAAG,IAAI,IAAI,QAAQ,QAAQ,KAAK,IAAI,GAAG,IAAI;AAAA,UAAA;AAE1E,sBAAY,OAAO,UAAU,QAAQ,MAAM,OAAO,GAAG;AAC9C;AACP,yBAAe,CAAC;AAAA,mBACN,OAAO;AACX,gBAAA,CAAC,MAAM,KAAK,IAAI;AACtB,gBAAM,iBAAiB,cAAc,MAAM,CAAC,CAAC;AAC7C,gBAAM,aACL,MAAM,CAAC,EAAE,WAAW,MAAM,cAAc,KAAK,MAAM,IAAI,EAAE,SAAS,KAAK;AAClE,gBAAA,WAAW,MAAM;AAEvB,mBAAS,CAAC,IAAI,MAAM,CAAC,EAAE;AAAA,YACtB,aAAa,OAAO,YAAY,IAAI,IAAI,IAAI,IAAI;AAAA,YAChD,aAAa,KAAK,OAAO;AAAA,UAAA;AAE1B,cAAI,OAAO,SAAS,CAAC,EAAE,SAAS,MAAM,CAAC,EAAE;AACzC,mBAAS,IAAI,IAAI,aACd,SAAS,IAAI,EAAE,QAAQ,OAAO,MAAM,YAAY,KAAK,CAAC,KAAK,GAAG,EAAE,IAChE,SAAS,IAAI,IAAI,MAAM;AAEtB,cAAA,UAAU,SAAS,KAAK,IAAI;AAChC,cAAI,iBAAiB,iBAAiB;AAClC,cAAA,WAAW,iBAAiB,QAAQ,QAAQ,KAAK,IAAI,QAAQ,MAAM,cAAc;AACrF,cAAI,SACH,iBAAiB,OAAY,SAAS,OACnC,MACA,KAAK,IAAI,KAAK,IAAI,gBAAgB,MAAM,IAAI,GAAG,SAAS,QAAQ,MAAM;AAC/D,qBAAA,QAAQ,SAAS,QAAQ,MAAM,UAAU,KAAK,IAAI,UAAU,MAAM,CAAC;AACvE;AACP,yBAAe,CAAC;AAAA,QACjB;AAAA,MACD;AAAA,IACU,WAAA,QAAQ,IAAI,OAAO,WAAW,IAAI;AAC5C,YAAM,QAAQ,OAAO;AACf,YAAA,CAAC,OAAO,QAAQ,IAAI,IAAI,SAAS,OAAO,OAAO,GAAG;AAClD,YAAA,SAAS,MAAM,MAAM,MAAM,OAAO,MAAM,IAAO,EAAA,SAAS,QAAQ;AACtE,YAAM,aAAa,WAAW,OAAO,OAAO,CAAC,IAAI,OAAO;AACxD;AAAA,QACC;AAAA,QACA;AAAA,QACA,SAAc,CAAC,CAAC;AAAA,QAChB,OAAY,CAAC;AAAA,QACb,SAAS,KAAK,IAAI,QAAQ,UAAU;AAAA,MAAA;AAE9B;AACP,qBAAe,CAAC;AAAA,IACjB;AAAA,EAAA,CACA;AACC,GAAC,QAAQ,OAAO,OAAO,EAAY;AAAA,IAAQ,CAC5C,SAAA,oBAAoB,QAAQ,MAAM,CAAK,MAAA;AACtC,YAAM,CAAC,OAAO,GAAG,IAAI,aAAa;AAC9B,UAAA,SAAS,OAAO,WAAW;AACxB,cAAA,CAAC,CAAC,IAAI,GAAG,QAAQ,IAAI,IAAI,SAAS,OAAO,OAAO,OAAO,GAAG;AAChE,YAAI,QAAQ,SAAS;AACpB,cAAI,EAAE,cAAe,QAAQ,YAAY,KAAK,UAAU;AAC5C,uBAAA,QAAQ,WAAW,MAAM,QAAQ,QAAQ,QAAQ,SAAS,SAAS,CAAC;AACxE;AACP,2BAAe,CAAC;AAAA,UACjB;AAAA,QAAA,OACM;AACI,oBAAA,UAAW,WAAW,IAAK;AACrC,cAAI,QAAQ;AAAO,uBAAW,QAAQ,IAAI,QAAQ,OAAO,CAAC,GAAG;AAC7D,yBAAe,CAAC;AAAA,QACjB;AAAA,MACD;AAAA,IAAA,CACA;AAAA,EAAA;AAEH;AA6CK,MAAA,cAAc,CAAC,eAAe,QAAQ;AAC3C,MAAI,KAAK;AACL,MAAA;AACA,MAAA;AACJ,MAAI,WAAW;AACX,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAEJ,QAAM,QAAoD,CAAA;AACpD,QAAA,SAAS,CAAC,UAAkB;AACjC,QAAI,SAAS,cAAc;AAC1B;AACA,YAAM,MAAM;AAAA,IACb;AACM,UAAA,OAAQ,KAAK,OAAQ,cAAc,CAAC,cAAc,OAAO,aAAa,GAAG,aAAa,CAAC,CAAC;AAAA,EAAA;AAEzF,QAAA,iBAAiB,CAAC,UAAkB;AACrC,QAAA,MAAM,KAAK,GAAG;AACjB,eAAS,QAAQ,MAAM,KAAK,EAAE,CAAC;AACtB,eAAA,kBAAkB,GAAG,MAAM,KAAK,EAAE,QAAQ,KAAK,IAAI,CAAC,CAAC;AAC9D,oBAAc,OAAO;AACP,oBAAA,WAAW,QAAQ;AAC5B,WAAA;AACQ,mBAAA;AAAA,IACd;AAAA,EAAA;AAGK,QAAA,OAAoB,CAAC,QAAQ,YAAY;AAC9C,WAAO,WAAW,UAAU;AACZ,oBAAA;AAChB,mBAAe,OAAO;AACtB,gBAAY,OAAO,CAAC;AACpB,eAAW,OAAO;AAEX,WAAA,YAAY,mBAAmB,MAAM;AAC9B,mBAAA;AACF,iBAAA;AAAA,IAAA,CACX;AAEmB,wBAAA,QAAQ,eAAe,CAAK,MAAA;AAC/C,UAAI,OAAO,EAAE;AACb,UAAI,YAAY,EAAE;AAClB,UAAI,OAAO,EAAE;AAET,UAAA,UAAU,KAAK,SAAS,GAAG;AAC9B,uBAAe,MAAM,UAAU,CAAC,KAAK,MAAM,KAAK,EAAE;AAClD,uBAAe,CAAC;AAAA,MAAA,WAEhB,EAAE,UACD,eACC,iBAAiB,aAAc,OAAO,WAAW,MAAM,UAAU,MAAM,EAAE,KAAK,WAC/E,CAAC,kBACA,QAAQ,OAAO,YAAY,QAC5B;AACD,cAAM,EAAE,EAAE,CAAC,IAAI,iBAAiB,aAAa;AAAA,MAC9C;AACW,iBAAA;AACA,iBAAA;AACA,iBAAA;AACK,sBAAA;AAAA,IAAA,CAChB;AACD,wBAAoB,QAAQ,SAAS,MAAM,OAAO,KAAU,CAAC,OAAO,CAAC;AACjD,wBAAA,QAAQ,WAAW,CAAK,MAAA;AACvC,UAAA,CAAC,QAAQ,UAAU;AAChB,cAAA,OAAO,gBAAgB,CAAC;AAC9B,cAAM,UAAU,EAAE;AACZ,cAAA,SAAS,QAAQ,OAAO,WAAW;AACnC,cAAA,SACJ,QAAQ,MAAM,KAAK,WAAW,MAAQ,CAAC,SAAS,QAAQ,OAAO,WAAW;AAC5E,YAAI,QAAQ;AACX,yBAAe,KAAK,CAAC;AACrB,yBAAe,CAAC;AAAA,mBACN,QAAQ;AAClB,yBAAe,KAAK,CAAC;AACrB,yBAAe,CAAC;AAAA,QACjB;AAAA,MACD;AAAA,IAAA,CACA;AAAA,EAAA;AAGF,OAAK,QAAQ,MAAM;AAClB,WAAO,CAAC;AACK,iBAAA;AAAA,EAAA;AAGT,OAAA,MAAM,CAAU,WAAA,KAAK,UAAU;AACpC,OAAK,KAAK,CAAA,WAAU,eAAe,KAAK,MAAM;AAEvC,SAAA;AACR;"}