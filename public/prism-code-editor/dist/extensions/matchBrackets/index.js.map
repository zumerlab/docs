{"version":3,"file":"index.js","sources":["../../../src/extensions/matchBrackets/index.ts"],"sourcesContent":["/** @module match-brackets */\r\n\r\nimport { BasicExtension } from \"../../index.js\"\r\nimport { Token, TokenStream } from \"../../prism/index.js\"\r\n\r\nexport interface BracketMatcher extends BasicExtension {\r\n\t/**\r\n\t * Array of tuples containing in the following order:\r\n\t * - The bracket's `Token`\r\n\t * - Its starting position\r\n\t * - Its level of nesting\r\n\t * - Its text content\r\n\t * - Whether it's an opening bracket\r\n\t * - Its ending position\r\n\t *\r\n\t * The order will likely change in the next major release\r\n\t */\r\n\treadonly brackets: Bracket[]\r\n\t/** Array mapping the index of a bracket to the index of its matching bracket. */\r\n\treadonly pairs: (number | undefined)[]\r\n}\r\n\r\n/**\r\n * Tuple containing in the following order:\r\n * - The bracket's `Token`\r\n * - Its starting position\r\n * - Its level of nesting\r\n * - Its text content\r\n * - Whether it's an opening bracket\r\n * - Its ending position\r\n *\r\n * The order will likely change in the next major release\r\n */\r\nexport type Bracket = [Token, number, number, string, boolean, number]\r\n\r\n/**\r\n * Extension that matches punctuation tokens together. Intended for matching brackets.\r\n *\r\n * The order inside `openingBrackets` and `closingBrackets` determines which characters\r\n * are matched together.\r\n * @param rainbowBrackets Whether to add extra classes to brackets for styling. Defaults to true.\r\n * @param openingBrackets Defaults to `\"([{\"`.\r\n * @param closingBrackets Defaults to `\")]}\"`.\r\n *\r\n * Adding the extension dynamically, will force a rerender to add those extra classes.\r\n *\r\n * Without rainbow brackets, this extension can be added dynamically with no side effects.\r\n */\r\nexport const matchBrackets = (\r\n\trainbowBrackets = true,\r\n\topeningBrackets = \"([{\",\r\n\tclosingBrackets = \")]}\",\r\n) => {\r\n\tlet bracketIndex: number\r\n\tlet sp: number\r\n\tconst stack: [number, number][] = []\r\n\tconst self: BracketMatcher = editor => {\r\n\t\teditor.extensions.matchBrackets = self\r\n\t\teditor.addListener(\"tokenize\", matchBrackets)\r\n\t\tif (rainbowBrackets && editor.tokens[0]) editor.update()\r\n\t\telse matchBrackets(editor.tokens)\r\n\t}\r\n\t// @ts-expect-error\r\n\tconst brackets: Bracket[] = (self.brackets = [])\r\n\t// @ts-expect-error\r\n\tconst pairMap: number[] = (self.pairs = [])\r\n\tconst matchBrackets = (tokens: TokenStream) => {\r\n\t\tpairMap.length = brackets.length = sp = bracketIndex = 0\r\n\t\tmatchRecursive(tokens, 0)\r\n\r\n\t\tif (rainbowBrackets) {\r\n\t\t\tfor (let i = 0, bracket: Bracket; (bracket = brackets[i]); ) {\r\n\t\t\t\tlet alias = bracket[0].alias\r\n\r\n\t\t\t\tbracket[0].alias =\r\n\t\t\t\t\t(alias ? alias + \" \" : \"\") +\r\n\t\t\t\t\t`bracket-${i++ in pairMap ? \"level-\" + (bracket[2] % 12) : \"error\"}`\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tconst matchRecursive = (tokens: TokenStream, position: number) => {\r\n\t\tlet token: string | Token\r\n\t\tlet i = 0\r\n\t\tfor (; (token = tokens[i++]); ) {\r\n\t\t\tlet length = token.length\r\n\t\t\tif (typeof token != \"string\") {\r\n\t\t\t\tlet content = token.content\r\n\r\n\t\t\t\tif (Array.isArray(content)) {\r\n\t\t\t\t\tmatchRecursive(content, position)\r\n\t\t\t\t} else if ((token.alias || token.type) == \"punctuation\") {\r\n\t\t\t\t\tlet openingType = testBracket(content, openingBrackets, length - 1)\r\n\t\t\t\t\tlet closingType = openingType || testBracket(content, closingBrackets, length - 1)\r\n\t\t\t\t\tif (closingType) {\r\n\t\t\t\t\t\tbrackets[bracketIndex] = [token, position, 0, content, !!openingType, position + length]\r\n\r\n\t\t\t\t\t\tif (openingType) stack[sp++] = [bracketIndex, openingType]\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tfor (let i = sp; i; ) {\r\n\t\t\t\t\t\t\t\tlet [index, type] = stack[--i]\r\n\t\t\t\t\t\t\t\tif (closingType == type) {\r\n\t\t\t\t\t\t\t\t\tpairMap[(pairMap[bracketIndex] = index)] = bracketIndex\r\n\t\t\t\t\t\t\t\t\tbrackets[bracketIndex][2] = brackets[index][2] = sp = i\r\n\t\t\t\t\t\t\t\t\ti = 0\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbracketIndex++\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tposition += length\r\n\t\t}\r\n\t}\r\n\r\n\treturn self\r\n}\r\n\r\nconst testBracket = (str: string, brackets: string, l: number) => {\r\n\treturn brackets.indexOf(str[0]) + 1 || (l && brackets.indexOf(str[l]) + 1)\r\n}\r\n"],"names":["matchBrackets","i"],"mappings":"AAgDO,MAAM,gBAAgB,CAC5B,kBAAkB,MAClB,kBAAkB,OAClB,kBAAkB,UACd;AACA,MAAA;AACA,MAAA;AACJ,QAAM,QAA4B,CAAA;AAClC,QAAM,OAAuB,CAAU,WAAA;AACtC,WAAO,WAAW,gBAAgB;AAC3B,WAAA,YAAY,YAAYA,cAAa;AACxC,QAAA,mBAAmB,OAAO,OAAO,CAAC;AAAG,aAAO,OAAO;AAAA;AAClDA,qBAAc,OAAO,MAAM;AAAA,EAAA;AAG3B,QAAA,WAAuB,KAAK,WAAW;AAEvC,QAAA,UAAqB,KAAK,QAAQ;AAClCA,QAAAA,iBAAgB,CAAC,WAAwB;AAC9C,YAAQ,SAAS,SAAS,SAAS,KAAK,eAAe;AACvD,mBAAe,QAAQ,CAAC;AAExB,QAAI,iBAAiB;AACpB,eAAS,IAAI,GAAG,SAAmB,UAAU,SAAS,CAAC,KAAM;AACxD,YAAA,QAAQ,QAAQ,CAAC,EAAE;AAEvB,gBAAQ,CAAC,EAAE,SACT,QAAQ,QAAQ,MAAM,MACvB,WAAW,OAAO,UAAU,WAAY,QAAQ,CAAC,IAAI,KAAM,OAAO;AAAA,MACpE;AAAA,IACD;AAAA,EAAA;AAEK,QAAA,iBAAiB,CAAC,QAAqB,aAAqB;AAC7D,QAAA;AACJ,QAAI,IAAI;AACA,WAAA,QAAQ,OAAO,GAAG,KAAM;AAC/B,UAAI,SAAS,MAAM;AACf,UAAA,OAAO,SAAS,UAAU;AAC7B,YAAI,UAAU,MAAM;AAEhB,YAAA,MAAM,QAAQ,OAAO,GAAG;AAC3B,yBAAe,SAAS,QAAQ;AAAA,QAAA,YACrB,MAAM,SAAS,MAAM,SAAS,eAAe;AACxD,cAAI,cAAc,YAAY,SAAS,iBAAiB,SAAS,CAAC;AAClE,cAAI,cAAc,eAAe,YAAY,SAAS,iBAAiB,SAAS,CAAC;AACjF,cAAI,aAAa;AACP,qBAAA,YAAY,IAAI,CAAC,OAAO,UAAU,GAAG,SAAS,CAAC,CAAC,aAAa,WAAW,MAAM;AAEnF,gBAAA;AAAa,oBAAM,IAAI,IAAI,CAAC,cAAc,WAAW;AAAA,iBACpD;AACKC,uBAAAA,KAAI,IAAIA,MAAK;AACrB,oBAAI,CAAC,OAAO,IAAI,IAAI,MAAM,EAAEA,EAAC;AAC7B,oBAAI,eAAe,MAAM;AACxB,0BAAS,QAAQ,YAAY,IAAI,KAAM,IAAI;AAClC,2BAAA,YAAY,EAAE,CAAC,IAAI,SAAS,KAAK,EAAE,CAAC,IAAI,KAAKA;AACtDA,uBAAI;AAAA,gBACL;AAAA,cACD;AAAA,YACD;AACA;AAAA,UACD;AAAA,QACD;AAAA,MACD;AACY,kBAAA;AAAA,IACb;AAAA,EAAA;AAGM,SAAA;AACR;AAEA,MAAM,cAAc,CAAC,KAAa,UAAkB,MAAc;AACjE,SAAO,SAAS,QAAQ,IAAI,CAAC,CAAC,IAAI,KAAM,KAAK,SAAS,QAAQ,IAAI,CAAC,CAAC,IAAI;AACzE;"}