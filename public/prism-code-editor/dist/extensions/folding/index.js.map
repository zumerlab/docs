{"version":3,"file":"index.js","sources":["../../../src/extensions/folding/index.ts"],"sourcesContent":["/** @module code-folding */\r\n\r\nimport { Extension, PrismEditor, numLines } from \"../../index.js\"\r\nimport { getLineBefore } from \"../../utils/index.js\"\r\nimport { createTemplate, languageMap } from \"../../core.js\"\r\nimport { BracketMatcher } from \"../matchBrackets/index.js\"\r\nimport { TagMatcher } from \"../matchTags.js\"\r\nimport { TokenStream, Token } from \"../../prism/index.js\"\r\nimport { addListener, getLineEnd } from \"../../utils/local.js\"\r\n\r\n/**\r\n * Callback used to add extra foldable ranges to an editor.\r\n * @param editor Editor the folding ranges are added to.\r\n * @param currentFolds The ranges that are currently foldable.\r\n * @returns An array of extra foldable ranges.\r\n */\r\nexport type FoldingRangeProvider = (\r\n\teditor: PrismEditor,\r\n\tcurrentFolds: [number, number][],\r\n) => [number, number][]\r\n\r\nexport interface ReadOnlyCodeFolding extends Extension {\r\n\t/** The code in the editor with no ranges collapsed. */\r\n\treadonly fullCode: string\r\n\t/**\r\n\t * Toggles whether a range is folded. Does not cause a rerender so it's possible to\r\n\t * toggle multiple folds simultaneously.\r\n\t * @param lineNumber The line number of the fold.\r\n\t * @param force If set to `true`, the range will only be folded.\r\n\t * If `false`, the range will only be unfolded.\r\n\t * If `undefined`, it will be toggled.\r\n\t * @returns A boolean indicating whether or not a fold was toggled which means\r\n\t * calling {@link updateFolds} in the near future is necessary.\r\n\t */\r\n\ttoggleFold(lineNumber: number, force?: boolean): boolean\r\n\t/** Call this after the {@link toggleFold} method to rerender the editor. */\r\n\tupdateFolds(): void\r\n}\r\n\r\nconst template = createTemplate(\"<div class=pce-fold><div> \")\r\nconst template2 = createTemplate(\"<div class=pce-unfold> <span title=Unfold>   </span> \")\r\n\r\nconst isMultiline = (str: string, start: number, end: number) =>\r\n\tstr.slice(start, end).includes(\"\\n\")\r\n\r\n/**\r\n * Extension only supporting read-only editors which adds code folding to the editor.\r\n *\r\n * To fold XML elements, a {@link TagMatcher} needs to be added before.\r\n *\r\n * To fold bracket pairs, a {@link BracketMatcher} needs to be added before.\r\n *\r\n * @param providers Callbacks that can add extra foldable ranges.\r\n *\r\n * Very minimal downsides to adding this extension dynamically.\r\n *\r\n * Requires styles from `prism-code-editor/code-folding.css`\r\n */\r\nconst readOnlyCodeFolding = (...providers: FoldingRangeProvider[]): ReadOnlyCodeFolding => {\r\n\tlet cEditor: PrismEditor\r\n\tlet value: string\r\n\tlet code: string\r\n\tlet lines: HTMLCollection\r\n\tlet lineNumberWidth: string\r\n\tlet textarea: HTMLTextAreaElement\r\n\tlet foldPositions: (undefined | [number, number])[]\r\n\r\n\tconst foldToggles: HTMLDivElement[] = []\r\n\tconst foldPlaceholders: HTMLDivElement[] = []\r\n\tconst foldedLines = new Set<number>()\r\n\tconst foldedRanges = new Set<[number, number]>()\r\n\r\n\tconst getPosition = (pos: number) => {\r\n\t\tlet result = pos\r\n\t\tfor (let [start, end] of foldedRanges) {\r\n\t\t\tif (pos > start) {\r\n\t\t\t\tif (pos < end) return -1\r\n\t\t\t\tresult -= end - start - 3\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result\r\n\t}\r\n\r\n\tconst toggleFold = (line: number) => {\r\n\t\tconst start = foldPositions[line]![0]\r\n\t\tconst addFold = (line: number) => {\r\n\t\t\tlet [start, end] = foldPositions[line]!\r\n\t\t\tlet expanded: boolean\r\n\t\t\tfor (let range of foldedRanges) {\r\n\t\t\t\tif (start <= range[0] && end > range[0]) {\r\n\t\t\t\t\tif (expanded!) foldedRanges.delete(range)\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\trange[0] = start\r\n\t\t\t\t\t\tif (end > range[1]) range[1] = end\r\n\t\t\t\t\t\texpanded = true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!expanded!) foldedRanges.add([start, end])\r\n\t\t}\r\n\r\n\t\tif (foldedLines.has(line)) {\r\n\t\t\tfoldedLines.delete(line)\r\n\t\t\tfor (let range of foldedRanges) {\r\n\t\t\t\tif (start == range[0]) {\r\n\t\t\t\t\tfoldedRanges.delete(range)\r\n\t\t\t\t\tfor (let currentLine of foldedLines) {\r\n\t\t\t\t\t\tconst pos = foldPositions[currentLine]![0]\r\n\t\t\t\t\t\tif (pos > start) addFold(currentLine)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfoldedLines.add(line)\r\n\t\t\taddFold(line)\r\n\t\t}\r\n\t}\r\n\r\n\tconst update = (line?: number) => {\r\n\t\tvalue = \"\"\r\n\t\tlet pos = 0\r\n\t\tlet ln = 1\r\n\t\tlet skippedLines: number[] = []\r\n\t\tlet sortedRanges = [...foldedRanges].sort((a, b) => a[0] - b[0])\r\n\r\n\t\tfor (let [start, end] of sortedRanges) {\r\n\t\t\tvalue += code.slice(pos, start) + \"   \"\r\n\t\t\tskippedLines[(ln += numLines(code, pos, start) - 1)] = numLines(code, start, (pos = end))\r\n\t\t}\r\n\r\n\t\ttextarea.value = value += code.slice(pos)\r\n\t\tif (line) textarea.setSelectionRange((pos = getPosition(foldPositions[line]![0])), pos)\r\n\t\tcEditor.update()\r\n\r\n\t\tfor (let i = 1, j = 0, l = lines.length; i < l; i++)\r\n\t\t\tlines[i].setAttribute(\"data-line\", <any>(j += skippedLines[i - 1] || 1))\r\n\r\n\t\tcEditor.scrollContainer.style.setProperty(\"--number-width\", lineNumberWidth)\r\n\t\tupdateFolds()\r\n\t}\r\n\r\n\tconst updateFolds = () => {\r\n\t\tfor (let line = 0, l = foldPositions.length, prev: Element; line < l; line++) {\r\n\t\t\tif (!foldPositions[line]) continue\r\n\t\t\tlet pos = getPosition(foldPositions[line]![0])\r\n\t\t\tif (pos + 1) {\r\n\t\t\t\tlet parent = lines[numLines(value, 0, pos)]\r\n\t\t\t\tlet el = foldToggles[line]\r\n\t\t\t\tlet isClosed = foldedLines.has(line)\r\n\t\t\t\tlet pos2 = getPosition(foldPositions[line]![1])\r\n\t\t\t\tif (!el) {\r\n\t\t\t\t\tel = foldToggles[line] = template()\r\n\t\t\t\t\tel.onclick = () => toggleAndUpdate(line)\r\n\t\t\t\t}\r\n\t\t\t\tif (parent != el.parentNode && parent != prev!) parent.prepend(el)\r\n\t\t\t\tprev = parent\r\n\t\t\t\tel.classList.toggle(\"closed-fold\", isClosed)\r\n\t\t\t\tel.title = `${isClosed ? \"Unf\" : \"F\"}old line`\r\n\t\t\t\tel = foldPlaceholders[line]\r\n\t\t\t\tif (isClosed) {\r\n\t\t\t\t\tif (!el) {\r\n\t\t\t\t\t\tel = foldPlaceholders[line] = template2()\r\n\t\t\t\t\t\tel.onclick = () => toggleAndUpdate(line)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t;(<Text>el.firstChild).data = getLineBefore(value, pos)\r\n\t\t\t\t\t;(<Text>el.lastChild).data = value.slice(pos2, getLineEnd(value, pos2))\r\n\t\t\t\t\tif (parent != el.parentNode) parent.prepend(el)\r\n\t\t\t\t} else el?.remove()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconst toggleAndUpdate = (line: number) => {\r\n\t\ttoggleFold(line)\r\n\t\tupdate(line)\r\n\t}\r\n\r\n\tconst createFolds = () => {\r\n\t\tfoldPositions = []\r\n\t\tfoldedRanges.clear()\r\n\t\tfoldedLines.clear()\r\n\t\tvalue = code = cEditor.value\r\n\t\tlineNumberWidth = Math.ceil(Math.log10(numLines(code))) + \".001ch\"\r\n\t\tconst folds: [number, number][] = []\r\n\t\tconst { matchTags, matchBrackets } = cEditor.extensions\r\n\r\n\t\tif (matchTags) {\r\n\t\t\tlet { tags, pairs } = matchTags\r\n\t\t\tfor (let i = 0, j: number, l = pairs.length; i < l; i++) {\r\n\t\t\t\tif ((j = pairs[i]!) > i && isMultiline(value, tags[i][2], tags[j][1])) {\r\n\t\t\t\t\tfolds.push([tags[i][2], tags[j][1]])\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (matchBrackets) {\r\n\t\t\tlet { brackets, pairs } = matchBrackets\r\n\t\t\tfor (let i = 0, j: number, l = pairs.length; i < l; i++) {\r\n\t\t\t\tif (\r\n\t\t\t\t\t(j = pairs[i]!) > i &&\r\n\t\t\t\t\tbrackets[i][3] != \"(\" &&\r\n\t\t\t\t\tisMultiline(value, brackets[i][1], brackets[j][1])\r\n\t\t\t\t)\r\n\t\t\t\t\tfolds.push([brackets[i][1] + brackets[i][3].length, brackets[j][1]])\r\n\t\t\t}\r\n\t\t}\r\n\t\tproviders.forEach(clb => folds.push(...clb(cEditor, folds)))\r\n\r\n\t\tfor (let i = 0, l = folds.length; i < l; i++) {\r\n\t\t\tconst [start, end] = folds[i],\r\n\t\t\t\tindex = numLines(value, 0, start)\r\n\r\n\t\t\tif (!foldPositions[index] || end > foldPositions[index]![1])\r\n\t\t\t\tfoldPositions[index] = [start, end]\r\n\t\t}\r\n\t\tupdateFolds()\r\n\t}\r\n\r\n\treturn {\r\n\t\tupdate(editor, options) {\r\n\t\t\tif (!cEditor) {\r\n\t\t\t\tcEditor = editor\r\n\t\t\t\ttextarea = editor.textarea\r\n\t\t\t\teditor.extensions.codeFold = this\r\n\t\t\t\tlines = editor.wrapper.children\r\n\t\t\t\tif (editor.tokens[0]) createFolds()\r\n\t\t\t}\r\n\t\t\teditor.scrollContainer.style.setProperty(\r\n\t\t\t\t\"--padding-left\",\r\n\t\t\t\toptions.lineNumbers == false ? \"calc(var(--_pse) + var(--_ns))\" : \"\",\r\n\t\t\t)\r\n\t\t\tsetTimeout(addListener(editor, \"update\", createFolds))\r\n\t\t},\r\n\t\tget fullCode() {\r\n\t\t\treturn code\r\n\t\t},\r\n\t\ttoggleFold: (lineNumber, force) =>\r\n\t\t\t!!foldPositions[lineNumber] &&\r\n\t\t\tfoldedLines.has(lineNumber) != force &&\r\n\t\t\t!toggleFold(lineNumber)!,\r\n\t\tupdateFolds: () => update(),\r\n\t}\r\n}\r\n\r\n/**\r\n * Folding range provider that allows folding of block comments. For this to work,\r\n * you need to befine block comments in the {@link languageMap} for the language.\r\n *\r\n * Simply pass this function as one of the arguments when calling {@link readOnlyCodeFolding}.\r\n */\r\nconst blockCommentFolding: FoldingRangeProvider = ({ tokens, value, options: { language } }) => {\r\n\tconst folds: [number, number][] = []\r\n\tconst findBlockComments = (tokens: TokenStream, position: number, language: string) => {\r\n\t\tfor (let i = 0, l = tokens.length; i < l; ) {\r\n\t\t\tconst token = <Token>tokens[i++]\r\n\t\t\tconst content = token.content\r\n\t\t\tconst length = token.length\r\n\t\t\tconst aliasType = token.alias || token.type\r\n\t\t\tif (aliasType == \"comment\" && isMultiline(value, position, position + length)) {\r\n\t\t\t\tlet comment = languageMap[language]?.comments?.block\r\n\t\t\t\tif (comment && value.indexOf(comment[0], position) == position)\r\n\t\t\t\t\tfolds.push([position + comment[0].length, position + length - comment[1].length])\r\n\t\t\t} else if (Array.isArray(content)) {\r\n\t\t\t\tfindBlockComments(\r\n\t\t\t\t\tcontent,\r\n\t\t\t\t\tposition,\r\n\t\t\t\t\taliasType.slice(0, 9) == \"language-\" ? aliasType.slice(9) : language,\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\tposition += length\r\n\t\t}\r\n\t}\r\n\r\n\tfindBlockComments(tokens, 0, language)\r\n\r\n\treturn folds\r\n}\r\n\r\n/**\r\n * Folding range provider that allows folding of titles and code blocks in markdown.\r\n *\r\n * Simply pass this function as one of the arguments when calling {@link readOnlyCodeFolding}.\r\n */\r\nconst markdownFolding: FoldingRangeProvider = ({ tokens, value, options: { language } }) => {\r\n\tlet folds: [number, number][] = []\r\n\tlet pos = 0\r\n\tlet openTitles: number[] = []\r\n\tlet levels: number\r\n\tlet closeTitles = (level: number) => {\r\n\t\tfor (let end = value.slice(0, pos).trimEnd().length; level <= levels; ) {\r\n\t\t\tfolds.push([openTitles[level++], end])\r\n\t\t}\r\n\t}\r\n\tif (language == \"markdown\" || language == \"md\") {\r\n\t\tfor (let i = 0, l = tokens.length; i < l; ) {\r\n\t\t\tconst token = <Token>tokens[i++]\r\n\t\t\tconst length = token.length\r\n\t\t\tconst type = token.type\r\n\t\t\tif (type == \"code\" && !token.alias) {\r\n\t\t\t\tlet content = <Token[]>(<Token>token).content\r\n\t\t\t\tfolds.push([\r\n\t\t\t\t\tpos + content[0].length + (content[1].content || \"\").length,\r\n\t\t\t\t\tpos + length - content[content.length - 1].length - 1,\r\n\t\t\t\t])\r\n\t\t\t}\r\n\t\t\tif (type == \"title\") {\r\n\t\t\t\tlet [token1, token2] = <Token[]>(<Token>token).content\r\n\t\t\t\tlet level = token1.type ? token1.length - 1 : (<string>token2.content)[0] == \"=\" ? 0 : 1\r\n\t\t\t\tcloseTitles(level)\r\n\t\t\t\topenTitles[(levels = level)] = pos + (token1.type ? length : token1.length - 1)\r\n\t\t\t}\r\n\r\n\t\t\tpos += length\r\n\t\t}\r\n\t\tcloseTitles(0)\r\n\t}\r\n\r\n\treturn folds\r\n}\r\n\r\nexport { readOnlyCodeFolding, markdownFolding, blockCommentFolding }\r\n"],"names":["line","start","tokens","language"],"mappings":"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"}