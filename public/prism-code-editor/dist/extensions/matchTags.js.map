{"version":3,"file":"matchTags.js","sources":["../../src/extensions/matchTags.ts"],"sourcesContent":["/** @module match-tags */\r\n\r\nimport { PrismEditor, BasicExtension } from \"../index.js\"\r\nimport { Token, TokenStream } from \"../prism/index.js\"\r\nimport { getClosestToken } from \"../utils/index.js\"\r\nimport { addTextareaListener } from \"../core.js\"\r\n\r\nconst voidlessLangs = \"xml,rss,atom,jsx,tsx,xquery,actionscript\".split(\",\")\r\nconst voidTags = /^(?:area|base|w?br|col|embed|hr|img|input|link|meta|source|track)$/i\r\n\r\n/**\r\n * Tuple containing in the following order:\r\n * - The tag's `Token`\r\n * - Its starting position\r\n * - Its ending position\r\n * - Its tag name\r\n * - Whether it's a closing tag\r\n * - Whether it's not self-closing\r\n */\r\nexport type Tag = [Token, number, number, string, boolean, boolean]\r\n\r\nexport interface TagMatcher {\r\n\t/**\r\n\t * Array of tuples containing in the following order:\r\n\t * - The tag's `Token`\r\n\t * - Its starting position\r\n\t * - Its ending position\r\n\t * - Its tag name\r\n\t * - Whether it's a closing tag\r\n\t * - Whether it's not self-closing\r\n\t * \r\n\t * The tags are sorted by their ending position\r\n\t */\r\n\treadonly tags: Tag[]\r\n\t/** Array mapping the index of a tag to the index of its matching tag. */\r\n\treadonly pairs: (number | undefined)[]\r\n}\r\n\r\n/**\r\n * Function that adds tag matching to the editor.\r\n * @returns An object containing all tags and pairs.\r\n */\r\nexport const createTagMatcher = (editor: PrismEditor): TagMatcher => {\r\n\tlet pairMap: number[] = []\r\n\tlet code: string\r\n\tlet tags: Tag[] = []\r\n\tlet tagIndex: number\r\n\tlet sp: number\r\n\tlet stack: [number, string][] = []\r\n\r\n\tlet matchTags = (tokens: TokenStream, language: string, value: string) => {\r\n\t\tcode = value\r\n\t\ttags.length = pairMap.length = tagIndex = sp = 0\r\n\t\tmatchTagsRecursive(tokens, language, 0)\r\n\t}\r\n\r\n\tlet matchTagsRecursive = (tokens: TokenStream, language: string, position: number) => {\r\n\t\tlet noVoidTags = voidlessLangs.includes(language)\r\n\t\tlet i = 0\r\n\t\tlet l = tokens.length\r\n\t\tfor (; i < l; ) {\r\n\t\t\tconst token = <Token>tokens[i++]\r\n\t\t\tconst content = token.content\r\n\t\t\tconst length = token.length\r\n\t\t\tif (Array.isArray(content)) {\r\n\t\t\t\tif (token.type == \"tag\" && code[position] == \"<\") {\r\n\t\t\t\t\tconst openLen = content[0].length\r\n\t\t\t\t\tconst tagName = content[2] ? code.substr(position + openLen, content[1].length) : \"\"\r\n\t\t\t\t\tconst notSelfClosing =\r\n\t\t\t\t\t\tcontent[content.length - 1].length < 2 && (noVoidTags || !voidTags.test(tagName))\r\n\r\n\t\t\t\t\tif (content[2] && noVoidTags) matchTagsRecursive(content, language, position)\r\n\r\n\t\t\t\t\tif (notSelfClosing) {\r\n\t\t\t\t\t\tif (openLen > 1) {\r\n\t\t\t\t\t\t\tfor (let i = sp; i; ) {\r\n\t\t\t\t\t\t\t\tif (tagName == stack[--i][1]) {\r\n\t\t\t\t\t\t\t\t\tpairMap[(pairMap[tagIndex] = stack[(sp = i)][0])] = tagIndex\r\n\t\t\t\t\t\t\t\t\ti = 0\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tstack[sp++] = [tagIndex, tagName]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttags[tagIndex++] = [\r\n\t\t\t\t\t\ttoken,\r\n\t\t\t\t\t\tposition,\r\n\t\t\t\t\t\tposition + length,\r\n\t\t\t\t\t\ttagName,\r\n\t\t\t\t\t\topenLen > 1,\r\n\t\t\t\t\t\tnotSelfClosing,\r\n\t\t\t\t\t]\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet lang = token.alias || token.type\r\n\t\t\t\t\tmatchTagsRecursive(\r\n\t\t\t\t\t\tcontent,\r\n\t\t\t\t\t\tlang.slice(0, 9) == \"language-\" ? lang.slice(9) : language,\r\n\t\t\t\t\t\tposition,\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tposition += length\r\n\t\t}\r\n\t}\r\n\r\n\teditor.addListener(\"tokenize\", matchTags)\r\n\r\n\tmatchTags(editor.tokens, editor.options.language, editor.value)\r\n\r\n\treturn {\r\n\t\ttags,\r\n\t\tpairs: pairMap,\r\n\t}\r\n}\r\n\r\nconst getClosestTagIndex = (pos: number, tags: TagMatcher[\"tags\"]) => {\r\n\tfor (let i = 0, l = tags.length; i < l; i++) if (tags[i][1] <= pos && tags[i][2] >= pos) return i\r\n}\r\n\r\n/**\r\n * Extension that adds an `active-tagname` class to matching HTML/XML/JSX tags when the\r\n * cursor is on either tag. If the editor doesn't have a {@link TagMatcher}, one is\r\n * created. Use the CSS selector `.active-tagname` to style the elements. Obviously don't\r\n * add this if the languages used don't have tags.\r\n */\r\nexport const matchTags = (): BasicExtension => editor => {\r\n\tlet openEl: Element | undefined, closeEl: Element | undefined\r\n\tconst { tags, pairs } = (editor.extensions.matchTags ||= createTagMatcher(editor))\r\n\tconst highlight = (remove?: boolean) =>\r\n\t\t[openEl, closeEl].forEach(el => {\r\n\t\t\tel && el.classList.toggle(\"active-tagname\", !remove)\r\n\t\t})\r\n\r\n\teditor.addListener(\"selectionChange\", ([start, end]) => {\r\n\t\tlet newEl1: Element | undefined\r\n\t\tlet newEl2: Element | undefined\r\n\t\tlet index: number\r\n\t\tif (start == end && editor.focused) {\r\n\t\t\tindex = getClosestTagIndex(start, tags)!\r\n\r\n\t\t\tif (index + 1) {\r\n\t\t\t\tindex = pairs[index]!\r\n\r\n\t\t\t\tif (index + 1 && (newEl1 = getClosestToken(editor, \".tag>.tag\"))) {\r\n\t\t\t\t\tnewEl2 = getClosestToken(editor, \".tag>.tag\", 2, 0, tags[index][1])\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (openEl != newEl1) {\r\n\t\t\thighlight(true)\r\n\t\t\topenEl = newEl1\r\n\t\t\tcloseEl = newEl2\r\n\t\t\thighlight()\r\n\t\t}\r\n\t})\r\n}\r\n\r\n/**\r\n * Extension that highlights `<` and `>` punctuation in XML tags.\r\n * @param className Class added to the active punctuation you can use to style them with CSS.\r\n * @param alwaysHighlight If true, the punctuation will always be highlighted when the cursor\r\n * is inside a tag. If not it will only be highlighted when the cursor is on the punctuation.\r\n */\r\nexport const highlightTagPunctuation =\r\n\t(className: string, alwaysHighlight?: boolean): BasicExtension =>\r\n\teditor => {\r\n\t\tlet openEl: HTMLSpanElement, closeEl: HTMLSpanElement\r\n\t\tconst { tags } = (editor.extensions.matchTags ||= createTagMatcher(editor))\r\n\t\tconst getPunctuation = (pos?: number) => getClosestToken(editor, \".tag>.punctuation\", 0, 0, pos)\r\n\t\tconst highlight = (remove?: boolean) =>\r\n\t\t\t[openEl, closeEl].forEach(el => {\r\n\t\t\t\tel && el.classList.toggle(className, !remove)\r\n\t\t\t})\r\n\r\n\t\tconst selectionChange = () => {\r\n\t\t\tlet [start, end] = editor.getSelection()\r\n\t\t\tlet newEl1: HTMLSpanElement\r\n\t\t\tlet newEl2: HTMLSpanElement\r\n\t\t\tif (start == end && editor.focused) {\r\n\t\t\t\tlet tag = tags[getClosestTagIndex(start, tags)!]\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\ttag &&\r\n\t\t\t\t\t(alwaysHighlight || (!getClosestToken(editor, \".tag>.tag\") && getPunctuation()))\r\n\t\t\t\t) {\r\n\t\t\t\t\tnewEl1 = getPunctuation(tag[1])!\r\n\t\t\t\t\tnewEl2 = getPunctuation(tag[2] - 1)!\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (openEl != newEl1! || closeEl != newEl2!) {\r\n\t\t\t\thighlight(true)\r\n\t\t\t\topenEl = newEl1!\r\n\t\t\t\tcloseEl = newEl2!\r\n\t\t\t\thighlight()\r\n\t\t\t}\r\n\t\t}\r\n\t\teditor.addListener(\"selectionChange\", selectionChange)\r\n\t\taddTextareaListener(editor, \"focus\", selectionChange)\r\n\t\taddTextareaListener(editor, \"blur\", selectionChange)\r\n\t}\r\n"],"names":["matchTags","i"],"mappings":";;AAOA,MAAM,gBAAgB,2CAA2C,MAAM,GAAG;AAC1E,MAAM,WAAW;AAkCJ,MAAA,mBAAmB,CAAC,WAAoC;AACpE,MAAI,UAAoB,CAAA;AACpB,MAAA;AACJ,MAAI,OAAc,CAAA;AACd,MAAA;AACA,MAAA;AACJ,MAAI,QAA4B,CAAA;AAEhC,MAAIA,aAAY,CAAC,QAAqB,UAAkB,UAAkB;AAClE,WAAA;AACP,SAAK,SAAS,QAAQ,SAAS,WAAW,KAAK;AAC5B,uBAAA,QAAQ,UAAU,CAAC;AAAA,EAAA;AAGvC,MAAI,qBAAqB,CAAC,QAAqB,UAAkB,aAAqB;AACjF,QAAA,aAAa,cAAc,SAAS,QAAQ;AAChD,QAAI,IAAI;AACR,QAAI,IAAI,OAAO;AACf,WAAO,IAAI,KAAK;AACT,YAAA,QAAe,OAAO,GAAG;AAC/B,YAAM,UAAU,MAAM;AACtB,YAAM,SAAS,MAAM;AACjB,UAAA,MAAM,QAAQ,OAAO,GAAG;AAC3B,YAAI,MAAM,QAAQ,SAAS,KAAK,QAAQ,KAAK,KAAK;AAC3C,gBAAA,UAAU,QAAQ,CAAC,EAAE;AAC3B,gBAAM,UAAU,QAAQ,CAAC,IAAI,KAAK,OAAO,WAAW,SAAS,QAAQ,CAAC,EAAE,MAAM,IAAI;AAClF,gBAAM,iBACL,QAAQ,QAAQ,SAAS,CAAC,EAAE,SAAS,MAAM,cAAc,CAAC,SAAS,KAAK,OAAO;AAE5E,cAAA,QAAQ,CAAC,KAAK;AAA+B,+BAAA,SAAS,UAAU,QAAQ;AAE5E,cAAI,gBAAgB;AACnB,gBAAI,UAAU,GAAG;AACPC,uBAAAA,KAAI,IAAIA,MAAK;AACrB,oBAAI,WAAW,MAAM,EAAEA,EAAC,EAAE,CAAC,GAAG;AACpB,0BAAA,QAAQ,QAAQ,IAAI,MAAO,KAAKA,EAAE,EAAE,CAAC,CAAE,IAAI;AACpDA,uBAAI;AAAA,gBACL;AAAA,cACD;AAAA,YAAA,OACM;AACN,oBAAM,IAAI,IAAI,CAAC,UAAU,OAAO;AAAA,YACjC;AAAA,UACD;AAEA,eAAK,UAAU,IAAI;AAAA,YAClB;AAAA,YACA;AAAA,YACA,WAAW;AAAA,YACX;AAAA,YACA,UAAU;AAAA,YACV;AAAA,UAAA;AAAA,QACD,OACM;AACF,cAAA,OAAO,MAAM,SAAS,MAAM;AAChC;AAAA,YACC;AAAA,YACA,KAAK,MAAM,GAAG,CAAC,KAAK,cAAc,KAAK,MAAM,CAAC,IAAI;AAAA,YAClD;AAAA,UAAA;AAAA,QAEF;AAAA,MACD;AACY,kBAAA;AAAA,IACb;AAAA,EAAA;AAGM,SAAA,YAAY,YAAYD,UAAS;AAExCA,aAAU,OAAO,QAAQ,OAAO,QAAQ,UAAU,OAAO,KAAK;AAEvD,SAAA;AAAA,IACN;AAAA,IACA,OAAO;AAAA,EAAA;AAET;AAEA,MAAM,qBAAqB,CAAC,KAAa,SAA6B;AACrE,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG;AAAS,QAAA,KAAK,CAAC,EAAE,CAAC,KAAK,OAAO,KAAK,CAAC,EAAE,CAAC,KAAK;AAAY,aAAA;AACjG;AAQa,MAAA,YAAY,MAAsB,CAAU,WAAA;;AACxD,MAAI,QAA6B;AAC3B,QAAA,EAAE,MAAM,WAAW,YAAO,YAAW,cAAlB,GAAkB,YAAc,iBAAiB,MAAM;AAC1E,QAAA,YAAY,CAAC,WAClB,CAAC,QAAQ,OAAO,EAAE,QAAQ,CAAM,OAAA;AAC/B,UAAM,GAAG,UAAU,OAAO,kBAAkB,CAAC,MAAM;AAAA,EAAA,CACnD;AAEF,SAAO,YAAY,mBAAmB,CAAC,CAAC,OAAO,GAAG,MAAM;AACnD,QAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA,SAAS,OAAO,OAAO,SAAS;AAC3B,cAAA,mBAAmB,OAAO,IAAI;AAEtC,UAAI,QAAQ,GAAG;AACd,gBAAQ,MAAM,KAAK;AAEnB,YAAI,QAAQ,MAAM,SAAS,gBAAgB,QAAQ,WAAW,IAAI;AACxD,mBAAA,gBAAgB,QAAQ,aAAa,GAAG,GAAG,KAAK,KAAK,EAAE,CAAC,CAAC;AAAA,QACnE;AAAA,MACD;AAAA,IACD;AACA,QAAI,UAAU,QAAQ;AACrB,gBAAU,IAAI;AACL,eAAA;AACC,gBAAA;AACA;IACX;AAAA,EAAA,CACA;AACF;AAQO,MAAM,0BACZ,CAAC,WAAmB,oBACpB,CAAU,WAAA;;AACT,MAAI,QAAyB;AAC7B,QAAM,EAAE,KAAK,KAAK,YAAO,YAAW,cAAlB,GAAkB,YAAc,iBAAiB,MAAM;AACnE,QAAA,iBAAiB,CAAC,QAAiB,gBAAgB,QAAQ,qBAAqB,GAAG,GAAG,GAAG;AACzF,QAAA,YAAY,CAAC,WAClB,CAAC,QAAQ,OAAO,EAAE,QAAQ,CAAM,OAAA;AAC/B,UAAM,GAAG,UAAU,OAAO,WAAW,CAAC,MAAM;AAAA,EAAA,CAC5C;AAEF,QAAM,kBAAkB,MAAM;AAC7B,QAAI,CAAC,OAAO,GAAG,IAAI,OAAO,aAAa;AACnC,QAAA;AACA,QAAA;AACA,QAAA,SAAS,OAAO,OAAO,SAAS;AACnC,UAAI,MAAM,KAAK,mBAAmB,OAAO,IAAI,CAAE;AAG9C,UAAA,QACC,mBAAoB,CAAC,gBAAgB,QAAQ,WAAW,KAAK,mBAC7D;AACQ,iBAAA,eAAe,IAAI,CAAC,CAAC;AAC9B,iBAAS,eAAe,IAAI,CAAC,IAAI,CAAC;AAAA,MACnC;AAAA,IACD;AACI,QAAA,UAAU,UAAW,WAAW,QAAS;AAC5C,gBAAU,IAAI;AACL,eAAA;AACC,gBAAA;AACA;IACX;AAAA,EAAA;AAEM,SAAA,YAAY,mBAAmB,eAAe;AACjC,sBAAA,QAAQ,SAAS,eAAe;AAChC,sBAAA,QAAQ,QAAQ,eAAe;AACpD;"}