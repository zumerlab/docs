{"version":3,"file":"index-BltwYS88.js","sources":["../src/core.ts"],"sourcesContent":["import type {\r\n\tEditorOptions,\r\n\tPrismEditor,\r\n\tKeyCommandCallback,\r\n\tLanguage,\r\n\tInputCommandCallback,\r\n\tEditorEventMap,\r\n\tInputSelection,\r\n\tEditorExtension,\r\n} from \"./types.js\"\r\nimport { highlightTokens, languages, tokenizeText, Grammar, TokenStream } from \"./prism/index.js\"\r\n\r\n/**\r\n * Creates a code editor using the specified container and options.\r\n * @param container Element to append the editor to or a selector.\r\n * This can also be a `ShadowRoot` or `DocumentFragment` for example.\r\n * If omitted, you must manually append the `scrollContainer` to the DOM.\r\n * @param options Options the editor is initialized with.\r\n * If omitted, the editor won't function until you call `setOptions`.\r\n * @param extensions Extensions added before the first render. You can still add extensions later.\r\n * @returns Object to interact with the created editor.\r\n */\r\nconst createEditor = (\r\n\tcontainer?: ParentNode | string | null,\r\n\toptions?: Partial<EditorOptions>,\r\n\t...extensions: EditorExtension[]\r\n): PrismEditor => {\r\n\tlet language: string\r\n\tlet grammar: Grammar\r\n\tlet prevLines: string[] = []\r\n\tlet activeLine: HTMLDivElement\r\n\tlet value = \"\"\r\n\tlet activeLineNumber: number\r\n\tlet removed = false\r\n\tlet focused = false\r\n\tlet handleSelectionChange = true\r\n\tlet tokens: TokenStream = []\r\n\tlet readOnly: boolean\r\n\tlet lineCount = 0\r\n\r\n\tconst scrollContainer = editorTemplate()\r\n\tconst wrapper = <HTMLDivElement>scrollContainer.firstChild\r\n\tconst lines = <HTMLCollectionOf<HTMLDivElement>>wrapper.children\r\n\tconst overlays = lines[0]\r\n\tconst textarea = <HTMLTextAreaElement>overlays.firstChild\r\n\tconst currentOptions: EditorOptions = { language: \"text\", value }\r\n\tconst currentExtensions = new Set(extensions)\r\n\tconst listeners: {\r\n\t\t[P in keyof EditorEventMap]?: Set<EditorEventMap[P]>\r\n\t} = {}\r\n\r\n\tconst setOptions = (options: Partial<EditorOptions>) => {\r\n\t\tObject.assign(currentOptions, options)\r\n\t\tvalue = options.value ?? value\r\n\t\tlanguage = currentOptions.language\r\n\r\n\t\tif (!languages[language]) throw Error(`Language '${language}' has no grammar.`)\r\n\r\n\t\treadOnly = !!currentOptions.readOnly\r\n\t\tscrollContainer.style.tabSize = <any>currentOptions.tabSize || 2\r\n\t\ttextarea.inputMode = readOnly ? \"none\" : \"\"\r\n\t\ttextarea.setAttribute(\"aria-readonly\", <any>readOnly)\r\n\t\tupdateClassName()\r\n\r\n\t\tupdateExtensions()\r\n\t\tif (grammar != (grammar = languages[language]) || value != textarea.value) {\r\n\t\t\tfocusRelatedTarget()\r\n\t\t\ttextarea.value = value\r\n\t\t\ttextarea.selectionEnd = 0\r\n\t\t\tupdate()\r\n\t\t}\r\n\t}\r\n\r\n\tconst update = () => {\r\n\t\ttokens = tokenizeText((value = textarea.value), grammar)\r\n\t\tdispatchEvent(\"tokenize\", tokens, language, value)\r\n\r\n\t\tlet newLines = highlightTokens(tokens).split(\"\\n\")\r\n\t\tlet start = 0\r\n\t\tlet end2 = lineCount\r\n\t\tlet end1 = (lineCount = newLines.length)\r\n\r\n\t\twhile (newLines[start] == prevLines[start] && start < end1) ++start\r\n\t\twhile (end1 && newLines[--end1] == prevLines[--end2]);\r\n\r\n\t\tif (start == end1 && start == end2) lines[start + 1].innerHTML = newLines[start] + \"\\n\"\r\n\t\telse {\r\n\t\t\tlet insertStart = end2 < start ? end2 : start - 1\r\n\t\t\tlet i = insertStart\r\n\t\t\tlet newHTML = \"\"\r\n\r\n\t\t\twhile (i < end1) newHTML += `<div class=pce-line aria-hidden=true>${newLines[++i]}\\n</div>`\r\n\t\t\tfor (i = end1 < start ? end1 : start - 1; i < end2; i++) lines[start + 1].remove()\r\n\t\t\tif (newHTML) lines[insertStart + 1].insertAdjacentHTML(\"afterend\", newHTML)\r\n\t\t\tfor (i = insertStart + 1; i < lineCount; ) lines[++i].setAttribute(\"data-line\", <any>i)\r\n\t\t\tscrollContainer.style.setProperty(\r\n\t\t\t\t\"--number-width\",\r\n\t\t\t\tMath.ceil(Math.log10(lineCount + 1)) + \".001ch\",\r\n\t\t\t)\r\n\t\t}\r\n\r\n\t\tdispatchEvent(\"update\", value)\r\n\t\tdispatchSelection(true)\r\n\t\tif (handleSelectionChange) setTimeout(setTimeout, 0, () => (handleSelectionChange = true))\r\n\r\n\t\tprevLines = newLines\r\n\t\thandleSelectionChange = false\r\n\t}\r\n\r\n\tconst updateExtensions = (newExtensions?: EditorExtension[]) => {\r\n\t\t;(newExtensions || currentExtensions).forEach(extension => {\r\n\t\t\tif (typeof extension == \"object\") {\r\n\t\t\t\textension.update(self, currentOptions)\r\n\t\t\t\tif (newExtensions) currentExtensions.add(extension)\r\n\t\t\t} else {\r\n\t\t\t\textension(self, currentOptions)\r\n\t\t\t\tif (!newExtensions) currentExtensions.delete(extension)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tconst updateClassName = ([start, end] = getInputSelection()) => {\r\n\t\tscrollContainer.className = `prism-code-editor language-${language}${\r\n\t\t\tcurrentOptions.lineNumbers == false ? \"\" : \" show-line-numbers\"\r\n\t\t} pce-${currentOptions.wordWrap ? \"\" : \"no\"}wrap${currentOptions.rtl ? \" pce-rtl\" : \"\"} pce-${\r\n\t\t\tstart < end ? \"has\" : \"no\"\r\n\t\t}-selection${focused ? \" pce-focus\" : \"\"}${readOnly ? \" pce-readonly\" : \"\"}`\r\n\t}\r\n\r\n\tconst getInputSelection = (): InputSelection => [\r\n\t\ttextarea.selectionStart,\r\n\t\ttextarea.selectionEnd,\r\n\t\ttextarea.selectionDirection,\r\n\t]\r\n\r\n\tconst keyCommandMap: Record<string, KeyCommandCallback | null> = {\r\n\t\tEscape() {\r\n\t\t\ttextarea.blur()\r\n\t\t},\r\n\t}\r\n\r\n\tconst inputCommandMap: Record<string, InputCommandCallback | null> = {}\r\n\r\n\t// Safari focuses the textarea if you change its selection or value programmatically\r\n\tconst focusRelatedTarget = () =>\r\n\t\tisWebKit &&\r\n\t\t!focused &&\r\n\t\taddTextareaListener(\r\n\t\t\tself,\r\n\t\t\t\"focus\",\r\n\t\t\te => {\r\n\t\t\t\tlet relatedTarget = <HTMLElement>e.relatedTarget\r\n\t\t\t\tif (relatedTarget) relatedTarget.focus()\r\n\t\t\t\telse textarea.blur()\r\n\t\t\t},\r\n\t\t\t{ once: true },\r\n\t\t)\r\n\r\n\tconst dispatchEvent = <T extends keyof EditorEventMap>(\r\n\t\tname: T,\r\n\t\t...args: Parameters<EditorEventMap[T]>\r\n\t) => {\r\n\t\t// @ts-expect-error\r\n\t\tlisteners[name]?.forEach(handler => handler.apply(self, args))\r\n\t\t// @ts-expect-error\r\n\t\tcurrentOptions[\"on\" + name[0].toUpperCase() + name.slice(1)]?.apply(self, args)\r\n\t}\r\n\r\n\tconst dispatchSelection = (force?: boolean) => {\r\n\t\tif (force || handleSelectionChange) {\r\n\t\t\tconst selection = getInputSelection()\r\n\t\t\tconst newLine =\r\n\t\t\t\tlines[(activeLineNumber = numLines(value, 0, selection[selection[2] < \"f\" ? 0 : 1]))]\r\n\r\n\t\t\tif (newLine != activeLine) {\r\n\t\t\t\tactiveLine?.classList.remove(\"active-line\")\r\n\t\t\t\tnewLine.classList.add(\"active-line\")\r\n\t\t\t\tactiveLine = newLine\r\n\t\t\t}\r\n\t\t\tupdateClassName(selection)\r\n\t\t\tdispatchEvent(\"selectionChange\", selection, value)\r\n\t\t}\r\n\t}\r\n\r\n\tconst self: PrismEditor = {\r\n\t\tscrollContainer,\r\n\t\twrapper,\r\n\t\toverlays,\r\n\t\ttextarea,\r\n\t\tget activeLine() {\r\n\t\t\treturn activeLine\r\n\t\t},\r\n\t\tget activeLineNumber() {\r\n\t\t\treturn activeLineNumber\r\n\t\t},\r\n\t\tget value() {\r\n\t\t\treturn value\r\n\t\t},\r\n\t\toptions: currentOptions,\r\n\t\tget focused() {\r\n\t\t\treturn focused\r\n\t\t},\r\n\t\tget removed() {\r\n\t\t\treturn removed\r\n\t\t},\r\n\t\tget tokens() {\r\n\t\t\treturn tokens\r\n\t\t},\r\n\t\tinputCommandMap,\r\n\t\tkeyCommandMap,\r\n\t\textensions: {},\r\n\t\tsetOptions,\r\n\t\tupdate,\r\n\t\tgetSelection: getInputSelection,\r\n\t\tsetSelection(start, end = start, direction) {\r\n\t\t\tfocusRelatedTarget()\r\n\t\t\ttextarea.setSelectionRange(start, end, direction)\r\n\t\t\tdispatchSelection(true)\r\n\t\t},\r\n\t\taddExtensions(...extensions) {\r\n\t\t\tupdateExtensions(extensions)\r\n\t\t},\r\n\t\taddListener(name, handler) {\r\n\t\t\t;(listeners[name] ||= new Set<any>()).add(handler)\r\n\t\t},\r\n\t\tremoveListener(name, handler) {\r\n\t\t\tlisteners[name]?.delete(handler)\r\n\t\t},\r\n\t\tremove() {\r\n\t\t\tscrollContainer.remove()\r\n\t\t\tremoved = true\r\n\t\t},\r\n\t}\r\n\r\n\taddTextareaListener(self, \"keydown\", e => {\r\n\t\tkeyCommandMap[e.key]?.(e, getInputSelection(), value) && preventDefault(e)\r\n\t})\r\n\r\n\taddTextareaListener(self, \"beforeinput\", e => {\r\n\t\tif (\r\n\t\t\treadOnly ||\r\n\t\t\t(e.inputType == \"insertText\" && inputCommandMap[e.data!]?.(e, getInputSelection(), value))\r\n\t\t)\r\n\t\t\tpreventDefault(e)\r\n\t})\r\n\taddTextareaListener(self, \"input\", update)\r\n\taddTextareaListener(self, \"blur\", () => {\r\n\t\tselectionChange = null\r\n\t\tfocused = false\r\n\t\tupdateClassName()\r\n\t})\r\n\taddTextareaListener(self, \"focus\", () => {\r\n\t\tselectionChange = dispatchSelection\r\n\t\tfocused = true\r\n\t\tupdateClassName()\r\n\t})\r\n\t// For browsers that support selectionchange on textareas\r\n\taddTextareaListener(self, \"selectionchange\", e => {\r\n\t\tdispatchSelection()\r\n\t\tpreventDefault(e)\r\n\t})\r\n\r\n\tgetElement(container)?.append(scrollContainer)\r\n\toptions && setOptions(options)\r\n\treturn self\r\n}\r\n\r\n/**\r\n * Almost identical to {@link createEditor}, but instead of appending the editor to your\r\n * element, the editor replaces it.\r\n *\r\n * The `textContent` of the placeholder will be the code in the editor unless `options.value` is defined.\r\n * @param placeholder Node or selector which will be replaced by the editor.\r\n * @param options Options the editor is initialized with.\r\n * @param extensions Extensions added before the first render. You can still add extensions later.\r\n * @returns Object to interact with the created editor.\r\n */\r\nconst editorFromPlaceholder = (\r\n\tplaceholder: string | ChildNode,\r\n\toptions: Partial<EditorOptions>,\r\n\t...extensions: EditorExtension[]\r\n) => {\r\n\tconst el = getElement(placeholder)!\r\n\tconst editor = createEditor(\r\n\t\tnull,\r\n\t\tObject.assign({ value: el.textContent }, options),\r\n\t\t...extensions,\r\n\t)\r\n\tel.replaceWith(editor.scrollContainer)\r\n\treturn editor\r\n}\r\n\r\nconst templateEl = /* @__PURE__ */ document.createElement(\"div\")\r\n\r\nconst createTemplate = <T extends Element = HTMLDivElement>(html: string) => {\r\n\ttemplateEl.innerHTML = html\r\n\tconst node = templateEl.firstChild!\r\n\treturn () => <T>node.cloneNode(true)\r\n}\r\n\r\nconst addTextareaListener = <T extends keyof HTMLElementEventMap>(\r\n\teditor: PrismEditor,\r\n\ttype: T,\r\n\tlistener: (this: HTMLTextAreaElement, ev: HTMLElementEventMap[T]) => any,\r\n\toptions?: boolean | AddEventListenerOptions,\r\n) => editor.textarea.addEventListener(type, listener, options)\r\n\r\nconst getElement = <T extends Node>(el?: T | string | null) =>\r\n\ttypeof el == \"string\" ? document.querySelector<HTMLElement>(el) : el\r\n\r\nconst userAgent = navigator.userAgent\r\nconst isMac = /Mac|iPhone|iPod|iPad/i.test(navigator.platform)\r\nconst isChrome = /Chrome\\//.test(userAgent)\r\nconst isWebKit = !isChrome && /AppleWebKit\\//.test(userAgent)\r\n\r\n/**\r\n * Counts number of lines in the string between `start` and `end`.\r\n * If start and end are excluded, the whole string is searched.\r\n */\r\nconst numLines = (str: string, start = 0, end = Infinity) => {\r\n\tlet count = 1\r\n\tfor (; (start = str.indexOf(\"\\n\", start) + 1) && start <= end; count++);\r\n\treturn count\r\n}\r\n\r\n/** Object storing all language specific behavior. */\r\nconst languageMap: Record<string, Language> = {}\r\n\r\nconst editorTemplate = /* @__PURE__ */ createTemplate(\r\n\t\"<div><div class=pce-wrapper><div class=pce-overlays><textarea spellcheck=false autocapitalize=off autocomplete=off>\",\r\n)\r\n\r\nconst preventDefault = (e: Event) => {\r\n\te.preventDefault()\r\n\te.stopImmediatePropagation()\r\n}\r\n\r\nlet selectionChange: null | (() => void)\r\n\r\ndocument.addEventListener(\"selectionchange\", () => selectionChange?.())\r\n\r\nexport {\r\n\tcreateEditor,\r\n\tlanguageMap,\r\n\tnumLines,\r\n\tcreateTemplate,\r\n\tisMac,\r\n\tisChrome,\r\n\tisWebKit,\r\n\tgetElement,\r\n\tpreventDefault,\r\n\teditorFromPlaceholder,\r\n\taddTextareaListener,\r\n}\r\n"],"names":["options","extensions"],"mappings":"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"}