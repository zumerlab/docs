{"version":3,"file":"csharp.js","sources":["../../../src/prism/languages/csharp.js"],"sourcesContent":["import { languages } from '../core.js';\r\nimport { extend, insertBefore } from '../utils/language.js';\r\nimport { nested, re, replace } from '../utils/shared.js';\r\nimport './clike.js';\r\n\r\nvar keywordsToPattern = words => `\\\\b(?:${words})\\\\b`;\r\n\r\n// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/\r\nvar typeKeyword = 'bool|char|decimal|double|dynamic|float|object|s?byte|string|u?int|u?long|u?short|var|void'\r\nvar typeDeclarationKeyword = 'class|enum|interface|record|struct'\r\nvar contextualKeyword = 'add|alias|and|ascending|async|await|by|descending|from(?!\\\\s*[^\\\\s\\\\w])|[gls]et|global|group|into|init(?=\\\\s*;)|join|nameof|not|notnull|on|or|orderby|partial|remove|select|unmanaged|value|when|where|with(?=\\\\s*{)'\r\nvar otherKeyword = 'abstract|as|[bc]ase|break|catch|checked|const|continue|default|delegate|do|else|event|explicit|extern|finally|fixed|for|foreach|goto|i[fns]|implicit|internal|lock|namespace|new|null|operator|out|override|params|private|protected|public|readonly|ref|return|sealed|sizeof|stackalloc|static|switch|this|throw|try|typeof|unchecked|unsafe|using|virtual|volatile|while|yield'\r\n\r\n// keywords\r\nvar typeDeclarationKeywords = keywordsToPattern(typeDeclarationKeyword);\r\nvar keywords = RegExp(keywordsToPattern(typeKeyword + '|' + typeDeclarationKeyword + '|' + contextualKeyword + '|' + otherKeyword));\r\nvar nonTypeKeywords = keywordsToPattern(typeDeclarationKeyword + '|' + contextualKeyword + '|' + otherKeyword);\r\nvar nonContextualKeywords = keywordsToPattern(typeKeyword + '|' + typeDeclarationKeyword + '|' + otherKeyword);\r\n\r\n// types\r\nvar generic = nested(/<(?:[^<>;=*/%&|^+-]|<self>)*>/.source, 2); // the idea behind the other forbidden characters is to prevent false positives. Same for tupleElement.\r\nvar nestedRound = nested(/\\((?:[^()]|<self>)*\\)/.source, 2);\r\nvar name = /@?\\b(?!\\d)\\w+\\b/.source;\r\nvar genericName = replace(/<0>(?:\\s*<1>)?/.source, [name, generic]);\r\nvar identifier = replace(/(?!<0>)<1>(?:\\s*\\.\\s*<1>)*/.source, [nonTypeKeywords, genericName]);\r\nvar array = /\\[\\s*(?:,\\s*)*\\]/.source;\r\nvar typeExpressionWithoutTuple = replace(/<0>(?:\\s*(?:\\?\\s*)?<1>)*(?:\\s*\\?)?/.source, [identifier, array]);\r\nvar tupleElement = replace(/[^()[\\],;%&|^=<>/*+-]|<0>|<1>|<2>/.source, [generic, nestedRound, array]);\r\nvar tuple = replace(/\\(<0>+(?:,<0>+)+\\)/.source, [tupleElement]);\r\nvar typeExpression = replace(/(?:<0>|<1>)(?:\\s*(?:\\?\\s*)?<2>)*(?:\\s*\\?)?/.source, [tuple, identifier, array]);\r\n\r\nvar typeInside = {\r\n\t'keyword': keywords,\r\n\t'punctuation': /[()[\\].,:<>?]/\r\n};\r\n\r\n// strings & characters\r\n// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#character-literals\r\n// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#string-literals\r\nvar character = /'(?:\\\\.|[^\\n'\\\\]|\\\\[Uux][a-fA-F\\d]{1,8})'/.source; // simplified pattern\r\nvar regularString = /\"(?:\\\\.|[^\\\\\\n\"])*\"/.source;\r\nvar verbatimString = /@\"(?:\"\"|\\\\[\\s\\S]|[^\\\\\"])*\"(?!\")/.source;\r\n\r\nvar cs = languages.dotnet = languages.cs = languages.csharp = extend('clike', {\r\n\t'string': [\r\n\t\t{\r\n\t\t\tpattern: re(/(^|[^$\\\\])<0>/.source, [verbatimString], 'g'),\r\n\t\t\tlookbehind: true,\r\n\t\t\tgreedy: true\r\n\t\t},\r\n\t\t{\r\n\t\t\tpattern: re(/(^|[^@$\\\\])<0>/.source, [regularString], 'g'),\r\n\t\t\tlookbehind: true,\r\n\t\t\tgreedy: true\r\n\t\t}\r\n\t],\r\n\t'class-name': [\r\n\t\t{\r\n\t\t\t// Using static\r\n\t\t\t// using static System.Math;\r\n\t\t\tpattern: re(/(\\busing\\s+static\\s+)<0>(?=\\s*;)/.source, [identifier]),\r\n\t\t\tlookbehind: true,\r\n\t\t\tinside: typeInside\r\n\t\t},\r\n\t\t{\r\n\t\t\t// Using alias (type)\r\n\t\t\t// using Project = PC.MyCompany.Project;\r\n\t\t\tpattern: re(/(\\busing\\s+<0>\\s*=\\s*)<1>(?=\\s*;)/.source, [name, typeExpression]),\r\n\t\t\tlookbehind: true,\r\n\t\t\tinside: typeInside\r\n\t\t},\r\n\t\t{\r\n\t\t\t// Using alias (alias)\r\n\t\t\t// using Project = PC.MyCompany.Project;\r\n\t\t\tpattern: re(/(\\busing\\s+)<0>(?=\\s*=)/.source, [name]),\r\n\t\t\tlookbehind: true\r\n\t\t},\r\n\t\t{\r\n\t\t\t// Type declarations\r\n\t\t\t// class Foo<A, B>\r\n\t\t\t// interface Foo<out A, B>\r\n\t\t\tpattern: re(/(\\b<0>\\s+)<1>/.source, [typeDeclarationKeywords, genericName]),\r\n\t\t\tlookbehind: true,\r\n\t\t\tinside: typeInside\r\n\t\t},\r\n\t\t{\r\n\t\t\t// Single catch exception declaration\r\n\t\t\t// catch(Foo)\r\n\t\t\t// (things like catch(Foo e) is covered by variable declaration)\r\n\t\t\tpattern: re(/(\\bcatch\\s*\\(\\s*)<0>/.source, [identifier]),\r\n\t\t\tlookbehind: true,\r\n\t\t\tinside: typeInside\r\n\t\t},\r\n\t\t{\r\n\t\t\t// Name of the type parameter of generic constraints\r\n\t\t\t// where Foo : class\r\n\t\t\tpattern: re(/(\\bwhere\\s+)<0>/.source, [name]),\r\n\t\t\tlookbehind: true\r\n\t\t},\r\n\t\t{\r\n\t\t\t// Casts and checks via as and is.\r\n\t\t\t// as Foo<A>, is Bar<B>\r\n\t\t\t// (things like if(a is Foo b) is covered by variable declaration)\r\n\t\t\tpattern: re(/(\\b(?:is(?:\\s+not)?|as)\\s+)<0>/.source, [typeExpressionWithoutTuple]),\r\n\t\t\tlookbehind: true,\r\n\t\t\tinside: typeInside\r\n\t\t},\r\n\t\t{\r\n\t\t\t// Variable, field and parameter declaration\r\n\t\t\t// (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)\r\n\t\t\tpattern: re(/\\b<0>(?=\\s+(?!<1>|with\\s*\\{)<2>(?:\\s*[=,:;{)\\]]|\\s+(?:in|when)\\b))/.source, [typeExpression, nonContextualKeywords, name]),\r\n\t\t\tinside: typeInside\r\n\t\t}\r\n\t],\r\n\t'keyword': keywords,\r\n\t// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals\r\n\t'number': /(?:\\b0(?:x[a-f\\d_]*[a-f\\d]|b[01_]*[01])|(?:\\B\\.\\d+(?:_+\\d+)*|\\b\\d+(?:_+\\d+)*(?:\\.\\d+(?:_+\\d+)*)?)(?:e[+-]?\\d+(?:_+\\d+)*)?)(?:[dflmu]|lu|ul)?\\b/i,\r\n\t'operator': /[=-]>|([&|+-])\\1|~|\\?\\?=?|>>=?|<<=?|[%&|^!=<>/*+-]=?/,\r\n\t'punctuation': /\\?\\.?|::|[()[\\]{}.,:;]/\r\n});\r\n\r\ninsertBefore(cs, 'number', {\r\n\t'range': {\r\n\t\tpattern: /\\.\\./,\r\n\t\talias: 'operator'\r\n\t}\r\n});\r\n\r\ninsertBefore(cs, 'punctuation', {\r\n\t'named-parameter': {\r\n\t\tpattern: re(/([(,]\\s*)<0>(?=\\s*:)/.source, [name]),\r\n\t\tlookbehind: true,\r\n\t\talias: 'punctuation'\r\n\t}\r\n});\r\n\r\ninsertBefore(cs, 'class-name', {\r\n\t'namespace': {\r\n\t\t// namespace Foo.Bar {}\r\n\t\t// using Foo.Bar;\r\n\t\tpattern: re(/(\\b(?:namespace|using)\\s+)<0>(?:\\s*\\.\\s*<0>)*(?=\\s*[;{])/.source, [name]),\r\n\t\tlookbehind: true,\r\n\t\tinside: {\r\n\t\t\t'punctuation': /\\./\r\n\t\t}\r\n\t},\r\n\t'type-expression': {\r\n\t\t// default(Foo), typeof(Foo<Bar>), sizeof(int)\r\n\t\tpattern: re(/(\\b(?:default|sizeof|typeof)\\s*\\(\\s*(?!\\s))(?:[^()\\s]|\\s(?!\\s)|<0>)+(?=\\s*\\))/.source, [nestedRound]),\r\n\t\tlookbehind: true,\r\n\t\talias: 'class-name',\r\n\t\tinside: typeInside\r\n\t},\r\n\t'return-type': {\r\n\t\t// Foo<Bar> ForBar(); Foo IFoo.Bar() => 0\r\n\t\t// int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];\r\n\t\t// int Foo => 0; int Foo { get; set } = 0;\r\n\t\tpattern: re(/<0>(?=\\s+(?:<1>\\s*(?:=>|[({]|\\.\\s*this\\s*\\[)|this\\s*\\[))/.source, [typeExpression, identifier]),\r\n\t\talias: 'class-name',\r\n\t\tinside: typeInside\r\n\t},\r\n\t'constructor-invocation': {\r\n\t\t// new List<Foo<Bar[]>> { }\r\n\t\tpattern: re(/(\\bnew\\s+)<0>(?=\\s*[[({])/.source, [typeExpression]),\r\n\t\tlookbehind: true,\r\n\t\talias: 'class-name',\r\n\t\tinside: typeInside\r\n\t},\r\n\t/*'explicit-implementation': {\r\n\t\t// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();\r\n\t\tpattern: replace(/\\b<0>(?=\\.<1>)/, className, methodOrPropertyDeclaration),\r\n\t\tinside: classNameInside,\r\n\t\talias: 'class-name'\r\n\t},*/\r\n\t'generic-method': {\r\n\t\t// foo<Bar>()\r\n\t\tpattern: re(/<0>\\s*<1>(?=\\s*\\()/.source, [name, generic]),\r\n\t\tinside: {\r\n\t\t\t'function': re(/^<0>/.source, [name]),\r\n\t\t\t'generic': {\r\n\t\t\t\tpattern: RegExp(generic),\r\n\t\t\t\talias: 'class-name',\r\n\t\t\t\tinside: typeInside\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t'type-list': {\r\n\t\t// The list of types inherited or of generic constraints\r\n\t\t// class Foo<F> : Bar, IList<FooBar>\r\n\t\t// where F : Bar, IList<int>\r\n\t\tpattern: re(\r\n\t\t\t/\\b((?:<0>\\s+<1>|record\\s+<1>\\s*<5>|where\\s+<2>)\\s*:\\s*)(?:<3>|<4>|<1>\\s*<5>|<6>)(?:\\s*,\\s*(?:<3>|<4>|<6>))*(?=\\s*(?:where|[{;]|=>|$))/.source,\r\n\t\t\t[typeDeclarationKeywords, genericName, name, typeExpression, keywords.source, nestedRound, /\\bnew\\s*\\(\\s*\\)/.source]\r\n\t\t),\r\n\t\tlookbehind: true,\r\n\t\tinside: {\r\n\t\t\t'record-arguments': {\r\n\t\t\t\tpattern: re(/(^(?!new\\s*\\()<0>\\s*)<1>/.source, [genericName, nestedRound], 'g'),\r\n\t\t\t\tlookbehind: true,\r\n\t\t\t\tgreedy: true,\r\n\t\t\t\tinside: cs\r\n\t\t\t},\r\n\t\t\t'keyword': keywords,\r\n\t\t\t'class-name': {\r\n\t\t\t\tpattern: RegExp(typeExpression, 'g'),\r\n\t\t\t\tgreedy: true,\r\n\t\t\t\tinside: typeInside\r\n\t\t\t},\r\n\t\t\t'punctuation': /[(),]/\r\n\t\t}\r\n\t},\r\n\t'preprocessor': {\r\n\t\tpattern: /(^[ \\t]*)#.*/m,\r\n\t\tlookbehind: true,\r\n\t\talias: 'property',\r\n\t\tinside: {\r\n\t\t\t// highlight preprocessor directives as keywords\r\n\t\t\t'directive': {\r\n\t\t\t\tpattern: /(#)\\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\\b/,\r\n\t\t\t\tlookbehind: true,\r\n\t\t\t\talias: 'keyword'\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\n// attributes\r\nvar regularStringOrCharacter = regularString + '|' + character;\r\nvar regularStringCharacterOrComment = replace(/\\/(?![*/])|\\/\\/[^\\n]*\\n|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<0>/.source, [regularStringOrCharacter]);\r\nvar roundExpression = nested(replace(/[^()\"'/]|<0>|\\(<self>*\\)/.source, [regularStringCharacterOrComment]), 2);\r\n\r\n// https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/#attribute-targets\r\nvar attrTarget = /\\b(?:assembly|event|field|method|module|param|property|return|type)\\b/.source;\r\nvar attr = replace(/<0>(?:\\s*\\(<1>*\\))?/.source, [identifier, roundExpression]);\r\n\r\n// string interpolation\r\nvar formatString = /:[^\\n}]+/.source;\r\n// multi line\r\nvar mInterpolationRound = nested(replace(/[^()\"'/]|<0>|\\(<self>*\\)/.source, [regularStringCharacterOrComment]), 2);\r\nvar mInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<0>)*<1>?\\}/.source, [mInterpolationRound, formatString]);\r\n// single line\r\nvar sInterpolationRound = nested(replace(/[^()\"'/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<0>|\\(<self>*\\)/.source, [regularStringOrCharacter]), 2);\r\nvar sInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<0>)*<1>?\\}/.source, [sInterpolationRound, formatString]);\r\n\r\nvar createInterpolationInside = (interpolation, interpolationRound) => ({\r\n\t'interpolation': {\r\n\t\tpattern: re(/((?:^|[^{])(?:\\{\\{)*)<0>/.source, [interpolation]),\r\n\t\tlookbehind: true,\r\n\t\tinside: {\r\n\t\t\t'format-string': {\r\n\t\t\t\tpattern: re(/(^\\{(?:(?![}:])<0>)*)<1>(?=\\}$)/.source, [interpolationRound, formatString]),\r\n\t\t\t\tlookbehind: true,\r\n\t\t\t\tinside: {\r\n\t\t\t\t\t'punctuation': /^:/\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t'punctuation': /^\\{|\\}$/,\r\n\t\t\t'expression': {\r\n\t\t\t\tpattern: /[\\s\\S]+/,\r\n\t\t\t\talias: 'language-csharp',\r\n\t\t\t\tinside: cs\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t'string': /[\\s\\S]+/\r\n});\r\n\r\ninsertBefore(cs, 'class-name', {\r\n\t'attribute': {\r\n\t\t// Attributes\r\n\t\t// [Foo], [Foo(1), Bar(2, Prop = \"foo\")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]\r\n\t\tpattern: re(/((?:^|[^\\s\\w>)?])\\s*\\[\\s*)(?:<0>\\s*:\\s*)?<1>(?:\\s*,\\s*<1>)*(?=\\s*\\])/.source, [attrTarget, attr], 'g'),\r\n\t\tlookbehind: true,\r\n\t\tgreedy: true,\r\n\t\tinside: {\r\n\t\t\t'target': {\r\n\t\t\t\tpattern: re(/^<0>(?=\\s*:)/.source, [attrTarget]),\r\n\t\t\t\talias: 'keyword'\r\n\t\t\t},\r\n\t\t\t'attribute-arguments': {\r\n\t\t\t\tpattern: re(/\\(<0>*\\)/.source, [roundExpression]),\r\n\t\t\t\tinside: cs\r\n\t\t\t},\r\n\t\t\t'class-name': {\r\n\t\t\t\tpattern: RegExp(identifier),\r\n\t\t\t\tinside: {\r\n\t\t\t\t\t'punctuation': /\\./\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t'punctuation': /[,:]/\r\n\t\t}\r\n\t}\r\n});\r\n\r\ninsertBefore(cs, 'string', {\r\n\t'interpolation-string': [\r\n\t\t{\r\n\t\t\tpattern: re(/(^|[^\\\\])(?:\\$@|@\\$)\"(?:\"\"|\\\\[\\s\\S]|\\{\\{|<0>|[^\\\\{\"])*\"/.source, [mInterpolation], 'g'),\r\n\t\t\tlookbehind: true,\r\n\t\t\tgreedy: true,\r\n\t\t\tinside: createInterpolationInside(mInterpolation, mInterpolationRound),\r\n\t\t},\r\n\t\t{\r\n\t\t\tpattern: re(/(^|[^@\\\\])\\$\"(?:\\\\.|\\{\\{|<0>|[^\\\\\"{])*\"/.source, [sInterpolation], 'g'),\r\n\t\t\tlookbehind: true,\r\n\t\t\tgreedy: true,\r\n\t\t\tinside: createInterpolationInside(sInterpolation, sInterpolationRound),\r\n\t\t}\r\n\t],\r\n\t'char': {\r\n\t\tpattern: RegExp(character, 'g'),\r\n\t\tgreedy: true\r\n\t}\r\n});\r\n"],"names":[],"mappings":";;;;AAKA,IAAI,oBAAoB,WAAS,SAAS,KAAK;AAG/C,IAAI,cAAc;AAClB,IAAI,yBAAyB;AAC7B,IAAI,oBAAoB;AACxB,IAAI,eAAe;AAGnB,IAAI,0BAA0B,kBAAkB,sBAAsB;AACtE,IAAI,WAAW,OAAO,kBAAkB,cAAc,MAAM,yBAAyB,MAAM,oBAAoB,MAAM,YAAY,CAAC;AAClI,IAAI,kBAAkB,kBAAkB,yBAAyB,MAAM,oBAAoB,MAAM,YAAY;AAC7G,IAAI,wBAAwB,kBAAkB,cAAc,MAAM,yBAAyB,MAAM,YAAY;AAG7G,IAAI,UAAU,OAAO,iCAAwC,CAAC;AAC9D,IAAI,cAAc,OAAO,2BAAgC,CAAC;AAC1D,IAAI,OAAO;AACX,IAAI,cAAc,QAAQ,mBAAyB,CAAC,MAAM,OAAO,CAAC;AAClE,IAAI,aAAa,QAAQ,iCAAqC,CAAC,iBAAiB,WAAW,CAAC;AAC5F,IAAI,QAAQ;AACZ,IAAI,6BAA6B,QAAQ,2CAA6C,CAAC,YAAY,KAAK,CAAC;AACzG,IAAI,eAAe,QAAQ,sCAA4C,CAAC,SAAS,aAAa,KAAK,CAAC;AACpG,IAAI,QAAQ,QAAQ,wBAA6B,CAAC,YAAY,CAAC;AAC/D,IAAI,iBAAiB,QAAQ,mDAAqD,CAAC,OAAO,YAAY,KAAK,CAAC;AAE5G,IAAI,aAAa;AAAA,EAChB,WAAW;AAAA,EACX,eAAe;AAChB;AAKA,IAAI,YAAY;AAChB,IAAI,gBAAgB;AACpB,IAAI,iBAAiB;AAErB,IAAI,KAAK,UAAU,SAAS,UAAU,KAAK,UAAU,SAAS,OAAO,SAAS;AAAA,EAC7E,UAAU;AAAA,IACT;AAAA,MACC,SAAS,GAAG,mBAAwB,CAAC,cAAc,GAAG,GAAG;AAAA,MACzD,YAAY;AAAA,MACZ,QAAQ;AAAA,IACR;AAAA,IACD;AAAA,MACC,SAAS,GAAG,oBAAyB,CAAC,aAAa,GAAG,GAAG;AAAA,MACzD,YAAY;AAAA,MACZ,QAAQ;AAAA,IACR;AAAA,EACD;AAAA,EACD,cAAc;AAAA,IACb;AAAA;AAAA;AAAA,MAGC,SAAS,GAAG,wCAA2C,CAAC,UAAU,CAAC;AAAA,MACnE,YAAY;AAAA,MACZ,QAAQ;AAAA,IACR;AAAA,IACD;AAAA;AAAA;AAAA,MAGC,SAAS,GAAG,0CAA4C,CAAC,MAAM,cAAc,CAAC;AAAA,MAC9E,YAAY;AAAA,MACZ,QAAQ;AAAA,IACR;AAAA,IACD;AAAA;AAAA;AAAA,MAGC,SAAS,GAAG,8BAAkC,CAAC,IAAI,CAAC;AAAA,MACpD,YAAY;AAAA,IACZ;AAAA,IACD;AAAA;AAAA;AAAA;AAAA,MAIC,SAAS,GAAG,mBAAwB,CAAC,yBAAyB,WAAW,CAAC;AAAA,MAC1E,YAAY;AAAA,MACZ,QAAQ;AAAA,IACR;AAAA,IACD;AAAA;AAAA;AAAA;AAAA,MAIC,SAAS,GAAG,4BAA+B,CAAC,UAAU,CAAC;AAAA,MACvD,YAAY;AAAA,MACZ,QAAQ;AAAA,IACR;AAAA,IACD;AAAA;AAAA;AAAA,MAGC,SAAS,GAAG,qBAA0B,CAAC,IAAI,CAAC;AAAA,MAC5C,YAAY;AAAA,IACZ;AAAA,IACD;AAAA;AAAA;AAAA;AAAA,MAIC,SAAS,GAAG,qCAAyC,CAAC,0BAA0B,CAAC;AAAA,MACjF,YAAY;AAAA,MACZ,QAAQ;AAAA,IACR;AAAA,IACD;AAAA;AAAA;AAAA,MAGC,SAAS,GAAG,8EAA6E,CAAC,gBAAgB,uBAAuB,IAAI,CAAC;AAAA,MACtI,QAAQ;AAAA,IACR;AAAA,EACD;AAAA,EACD,WAAW;AAAA;AAAA,EAEX,UAAU;AAAA,EACV,YAAY;AAAA,EACZ,eAAe;AAChB,CAAC;AAED,aAAa,IAAI,UAAU;AAAA,EAC1B,SAAS;AAAA,IACR,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AACF,CAAC;AAED,aAAa,IAAI,eAAe;AAAA,EAC/B,mBAAmB;AAAA,IAClB,SAAS,GAAG,0BAA+B,CAAC,IAAI,CAAC;AAAA,IACjD,YAAY;AAAA,IACZ,OAAO;AAAA,EACP;AACF,CAAC;AAED,aAAa,IAAI,cAAc;AAAA,EAC9B,aAAa;AAAA;AAAA;AAAA,IAGZ,SAAS,GAAG,kEAAmE,CAAC,IAAI,CAAC;AAAA,IACrF,YAAY;AAAA,IACZ,QAAQ;AAAA,MACP,eAAe;AAAA,IACf;AAAA,EACD;AAAA,EACD,mBAAmB;AAAA;AAAA,IAElB,SAAS,GAAG,2FAAwF,CAAC,WAAW,CAAC;AAAA,IACjH,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,QAAQ;AAAA,EACR;AAAA,EACD,eAAe;AAAA;AAAA;AAAA;AAAA,IAId,SAAS,GAAG,oEAAmE,CAAC,gBAAgB,UAAU,CAAC;AAAA,IAC3G,OAAO;AAAA,IACP,QAAQ;AAAA,EACR;AAAA,EACD,0BAA0B;AAAA;AAAA,IAEzB,SAAS,GAAG,gCAAoC,CAAC,cAAc,CAAC;AAAA,IAChE,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,QAAQ;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,kBAAkB;AAAA;AAAA,IAEjB,SAAS,GAAG,yBAA6B,CAAC,MAAM,OAAO,CAAC;AAAA,IACxD,QAAQ;AAAA,MACP,YAAY,GAAG,QAAe,CAAC,IAAI,CAAC;AAAA,MACpC,WAAW;AAAA,QACV,SAAS,OAAO,OAAO;AAAA,QACvB,OAAO;AAAA,QACP,QAAQ;AAAA,MACR;AAAA,IACD;AAAA,EACD;AAAA,EACD,aAAa;AAAA;AAAA;AAAA;AAAA,IAIZ,SAAS;AAAA,MACR;AAAA,MACA,CAAC,yBAAyB,aAAa,MAAM,gBAAgB,SAAS,QAAQ,aAAa,sBAAwB;AAAA,IACnH;AAAA,IACD,YAAY;AAAA,IACZ,QAAQ;AAAA,MACP,oBAAoB;AAAA,QACnB,SAAS,GAAG,+BAAmC,CAAC,aAAa,WAAW,GAAG,GAAG;AAAA,QAC9E,YAAY;AAAA,QACZ,QAAQ;AAAA,QACR,QAAQ;AAAA,MACR;AAAA,MACD,WAAW;AAAA,MACX,cAAc;AAAA,QACb,SAAS,OAAO,gBAAgB,GAAG;AAAA,QACnC,QAAQ;AAAA,QACR,QAAQ;AAAA,MACR;AAAA,MACD,eAAe;AAAA,IACf;AAAA,EACD;AAAA,EACD,gBAAgB;AAAA,IACf,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,QAAQ;AAAA;AAAA,MAEP,aAAa;AAAA,QACZ,SAAS;AAAA,QACT,YAAY;AAAA,QACZ,OAAO;AAAA,MACP;AAAA,IACD;AAAA,EACD;AACF,CAAC;AAGD,IAAI,2BAA2B,gBAAgB,MAAM;AACrD,IAAI,kCAAkC,QAAQ,uDAAiE,CAAC,wBAAwB,CAAC;AACzI,IAAI,kBAAkB,OAAO,QAAQ,8BAAmC,CAAC,+BAA+B,CAAC,GAAG,CAAC;AAG7G,IAAI,aAAa;AACjB,IAAI,OAAO,QAAQ,0BAA8B,CAAC,YAAY,eAAe,CAAC;AAG9E,IAAI,eAAe;AAEnB,IAAI,sBAAsB,OAAO,QAAQ,8BAAmC,CAAC,+BAA+B,CAAC,GAAG,CAAC;AACjH,IAAI,iBAAiB,QAAQ,qCAAyC,CAAC,qBAAqB,YAAY,CAAC;AAEzG,IAAI,sBAAsB,OAAO,QAAQ,kEAAuE,CAAC,wBAAwB,CAAC,GAAG,CAAC;AAC9I,IAAI,iBAAiB,QAAQ,qCAAyC,CAAC,qBAAqB,YAAY,CAAC;AAEzG,IAAI,4BAA4B,CAAC,eAAe,wBAAwB;AAAA,EACvE,iBAAiB;AAAA,IAChB,SAAS,GAAG,8BAAmC,CAAC,aAAa,CAAC;AAAA,IAC9D,YAAY;AAAA,IACZ,QAAQ;AAAA,MACP,iBAAiB;AAAA,QAChB,SAAS,GAAG,qCAA0C,CAAC,oBAAoB,YAAY,CAAC;AAAA,QACxF,YAAY;AAAA,QACZ,QAAQ;AAAA,UACP,eAAe;AAAA,QACf;AAAA,MACD;AAAA,MACD,eAAe;AAAA,MACf,cAAc;AAAA,QACb,SAAS;AAAA,QACT,OAAO;AAAA,QACP,QAAQ;AAAA,MACR;AAAA,IACD;AAAA,EACD;AAAA,EACD,UAAU;AACX;AAEA,aAAa,IAAI,cAAc;AAAA,EAC9B,aAAa;AAAA;AAAA;AAAA,IAGZ,SAAS,GAAG,mFAA+E,CAAC,YAAY,IAAI,GAAG,GAAG;AAAA,IAClH,YAAY;AAAA,IACZ,QAAQ;AAAA,IACR,QAAQ;AAAA,MACP,UAAU;AAAA,QACT,SAAS,GAAG,iBAAuB,CAAC,UAAU,CAAC;AAAA,QAC/C,OAAO;AAAA,MACP;AAAA,MACD,uBAAuB;AAAA,QACtB,SAAS,GAAG,cAAmB,CAAC,eAAe,CAAC;AAAA,QAChD,QAAQ;AAAA,MACR;AAAA,MACD,cAAc;AAAA,QACb,SAAS,OAAO,UAAU;AAAA,QAC1B,QAAQ;AAAA,UACP,eAAe;AAAA,QACf;AAAA,MACD;AAAA,MACD,eAAe;AAAA,IACf;AAAA,EACD;AACF,CAAC;AAED,aAAa,IAAI,UAAU;AAAA,EAC1B,wBAAwB;AAAA,IACvB;AAAA,MACC,SAAS,GAAG,uEAAkE,CAAC,cAAc,GAAG,GAAG;AAAA,MACnG,YAAY;AAAA,MACZ,QAAQ;AAAA,MACR,QAAQ,0BAA0B,gBAAgB,mBAAmB;AAAA,IACrE;AAAA,IACD;AAAA,MACC,SAAS,GAAG,oDAAkD,CAAC,cAAc,GAAG,GAAG;AAAA,MACnF,YAAY;AAAA,MACZ,QAAQ;AAAA,MACR,QAAQ,0BAA0B,gBAAgB,mBAAmB;AAAA,IACrE;AAAA,EACD;AAAA,EACD,QAAQ;AAAA,IACP,SAAS,OAAO,WAAW,GAAG;AAAA,IAC9B,QAAQ;AAAA,EACR;AACF,CAAC;"}