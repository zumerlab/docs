{"version":3,"file":"cpp.js","sources":["../../../src/prism/languages/cpp.js"],"sourcesContent":["import { languages } from '../core.js';\r\nimport { extend, insertBefore } from '../utils/language.js';\r\nimport { boolean } from '../utils/patterns.js';\r\nimport { re } from '../utils/shared.js';\r\nimport './c.js';\r\n\r\nvar keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\r\n\r\nvar cpp = languages.cpp = extend('c', {\r\n\t'class-name': [\r\n\t\t{\r\n\t\t\tpattern: RegExp(`(\\\\b(?:class|concept|enum|struct|typename)\\\\s+)(?!${keyword.source})\\\\w+`),\r\n\t\t\tlookbehind: true\r\n\t\t},\r\n\t\t// This is intended to capture the class name of method implementations like:\r\n\t\t//   void foo::bar() const {}\r\n\t\t// However! The `foo` in the above example could also be a namespace, so we only capture the class name if\r\n\t\t// it starts with an uppercase letter. This approximation should give decent results.\r\n\t\t/\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\r\n\t\t// This will capture the class name before destructors like:\r\n\t\t//   Foo::~Foo() {}\r\n\t\t/\\b[a-z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\r\n\t\t// This also intends to capture the class name of method implementations but here the class has template\r\n\t\t// parameters, so it can't be a namespace (until C++ adds generic namespaces).\r\n\t\t/\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\r\n\t],\r\n\t'keyword': keyword,\r\n\t'number': {\r\n\t\tpattern: /(?:\\b0b[01']+|\\b0x(?:[a-f\\d']+(?:\\.[a-f\\d']*)?|\\.[a-f\\d']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/gi,\r\n\t\tgreedy: true\r\n\t},\r\n\t'operator': /->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|>>=?|<<=?|[%&|^!=<>/*+-]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|x?or|x?or_eq)\\b/,\r\n\t'boolean': boolean\r\n});\r\n\r\ninsertBefore(cpp, 'string', {\r\n\t'module': {\r\n\t\t// https://en.cppreference.com/w/cpp/language/modules\r\n\t\tpattern: re(\r\n\t\t\t/(\\b(?:import|module)\\s+)(?:\"(?:\\\\[\\s\\S]|[^\\\\\\n\"])*\"|<[^<>\\n]*>|<0>(?:\\s*:\\s*<0>)?|:\\s*<0>)/.source, [`\\\\b(?!${keyword.source})\\\\w+(?:\\\\s*\\\\.\\\\s*\\\\w+)*\\\\b`], 'g'\r\n\t\t),\r\n\t\tlookbehind: true,\r\n\t\tgreedy: true,\r\n\t\tinside: {\r\n\t\t\t'string': /^[<\"][\\s\\S]+/,\r\n\t\t\t'operator': /:/,\r\n\t\t\t'punctuation': /\\./\r\n\t\t}\r\n\t},\r\n\t'raw-string': {\r\n\t\tpattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/g,\r\n\t\tgreedy: true,\r\n\t\talias: 'string'\r\n\t}\r\n});\r\n\r\ninsertBefore(cpp, 'keyword', {\r\n\t'generic-function': {\r\n\t\tpattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\r\n\t\tinside: {\r\n\t\t\t'function': /^\\w+/,\r\n\t\t\t'generic': {\r\n\t\t\t\tpattern: /<[\\s\\S]+/,\r\n\t\t\t\talias: 'class-name',\r\n\t\t\t\tinside: cpp\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\ninsertBefore(cpp, 'operator', {\r\n\t'double-colon': {\r\n\t\tpattern: /::/,\r\n\t\talias: 'punctuation'\r\n\t}\r\n});\r\n\r\nvar baseClauseInside = Object.assign({}, cpp);\r\n\r\ninsertBefore(cpp, 'class-name', {\r\n\t// the base clause is an optional list of parent classes\r\n\t// https://en.cppreference.com/w/cpp/language/class\r\n\t'base-clause': {\r\n\t\tpattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/g,\r\n\t\tlookbehind: true,\r\n\t\tgreedy: true,\r\n\t\tinside: baseClauseInside\r\n\t}\r\n});\r\n\r\ninsertBefore(baseClauseInside, 'double-colon', {\r\n\t// All untokenized words that are not namespaces should be class names\r\n\t'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\r\n});\r\n"],"names":[],"mappings":";;;;;AAMA,IAAI,UAAU;AAEd,IAAI,MAAM,UAAU,MAAM,OAAO,KAAK;AAAA,EACrC,cAAc;AAAA,IACb;AAAA,MACC,SAAS,OAAO,qDAAqD,QAAQ,MAAM,OAAO;AAAA,MAC1F,YAAY;AAAA,IACZ;AAAA;AAAA;AAAA;AAAA;AAAA,IAKD;AAAA;AAAA;AAAA,IAGA;AAAA;AAAA;AAAA,IAGA;AAAA,EACA;AAAA,EACD,WAAW;AAAA,EACX,UAAU;AAAA,IACT,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA,EACD,YAAY;AAAA,EACZ,WAAW;AACZ,CAAC;AAED,aAAa,KAAK,UAAU;AAAA,EAC3B,UAAU;AAAA;AAAA,IAET,SAAS;AAAA,MACR;AAAA,MAAqG,CAAC,SAAS,QAAQ,MAAM,8BAA8B;AAAA,MAAG;AAAA,IAC9J;AAAA,IACD,YAAY;AAAA,IACZ,QAAQ;AAAA,IACR,QAAQ;AAAA,MACP,UAAU;AAAA,MACV,YAAY;AAAA,MACZ,eAAe;AAAA,IACf;AAAA,EACD;AAAA,EACD,cAAc;AAAA,IACb,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,OAAO;AAAA,EACP;AACF,CAAC;AAED,aAAa,KAAK,WAAW;AAAA,EAC5B,oBAAoB;AAAA,IACnB,SAAS;AAAA,IACT,QAAQ;AAAA,MACP,YAAY;AAAA,MACZ,WAAW;AAAA,QACV,SAAS;AAAA,QACT,OAAO;AAAA,QACP,QAAQ;AAAA,MACR;AAAA,IACD;AAAA,EACD;AACF,CAAC;AAED,aAAa,KAAK,YAAY;AAAA,EAC7B,gBAAgB;AAAA,IACf,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AACF,CAAC;AAED,IAAI,mBAAmB,OAAO,OAAO,CAAE,GAAE,GAAG;AAE5C,aAAa,KAAK,cAAc;AAAA;AAAA;AAAA,EAG/B,eAAe;AAAA,IACd,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,QAAQ;AAAA,IACR,QAAQ;AAAA,EACR;AACF,CAAC;AAED,aAAa,kBAAkB,gBAAgB;AAAA;AAAA,EAE9C,cAAc;AACf,CAAC;"}