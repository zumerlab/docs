{"version":3,"file":"sml.js","sources":["../../../src/prism/languages/sml.js"],"sourcesContent":["import { languages } from '../core.js';\r\nimport { clikePunctuation } from '../utils/patterns.js';\r\nimport { re, replace } from '../utils/shared.js';\r\n\r\nvar keywords = /\\b(?:abstype|[ae]nd|andalso|as|case|datatype|do|else|eqtype|exception|fu?n|functor|handle|if|in|include|infixr?|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\b/i;\r\n\r\nvar longId = `(?!${keywords.source})[a-z\\\\d_][\\\\w'.]*`;\r\n\r\nvar class0 = {\r\n\t// This is only an approximation since the real grammar is context-free\r\n\t//\r\n\t// Why the main loop so complex?\r\n\t// The main loop is approximately the same as /(?:\\s*(?:[*,]|->)\\s*<TERMINAL>)*/ which is, obviously, a lot\r\n\t// simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be\r\n\t// followed by a long identifier.\r\n\tpattern: re(\r\n\t\t/((?:^|[^:]):\\s*)<0>(?:\\s*(?:(?:\\*|->)\\s*<0>|,\\s*<0>(?:(?=\\s*(?:[*,]|->))|(?!\\s*(?:[*,]|->))\\s+<1>)))*/.source,\r\n\t\t[replace(/(?:'[\\w']*|<0>|\\((?:[^()]|\\([^)]*\\))*\\)|\\{(?:[^{}]|\\{[^}]*\\})*\\})(?:\\s+<0>)*/.source, [longId]), longId],\r\n\t\t'gi'\r\n\t),\r\n\tlookbehind: true,\r\n\tgreedy: true\r\n};\r\n\r\nclass0.inside = languages.smlnj = languages.sml = {\r\n\t// allow one level of nesting\r\n\t'comment': /\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*)|\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*))*\\*\\))*\\*\\)/,\r\n\t'string': {\r\n\t\tpattern: /#?\"(?:\\\\.|[^\\\\\"])*\"/g,\r\n\t\tgreedy: true\r\n\t},\r\n\r\n\t'class-name': [\r\n\t\tclass0,\r\n\t\t{\r\n\t\t\tpattern: /((?:^|[^\\w'])(?:datatype|exception|functor|signature|structure|type)\\s+)[a-z_][\\w'.]*/i,\r\n\t\t\tlookbehind: true\r\n\t\t}\r\n\t],\r\n\t'function': {\r\n\t\tpattern: /((?:^|[^\\w'])fun\\s+)[a-z_][\\w'.]*/i,\r\n\t\tlookbehind: true\r\n\t},\r\n\r\n\t'keyword': keywords,\r\n\t'variable': {\r\n\t\tpattern: /(^|[^\\w'])'[\\w']*/,\r\n\t\tlookbehind: true,\r\n\t},\r\n\r\n\t'number': /~?\\b(?:\\d+(?:\\.\\d+)?(?:e~?\\d+)?|0x[a-f\\d]+)\\b/i,\r\n\t'word': {\r\n\t\tpattern: /\\b0w(?:\\d+|x[a-f\\d]+)\\b/i,\r\n\t\talias: 'constant'\r\n\t},\r\n\r\n\t'boolean': /\\b(?:false|true)\\b/i,\r\n\t'operator': /\\.{3}|:[>=:]|=>?|->|[<>]=?|[|^#@~!/*+-]/,\r\n\t'punctuation': clikePunctuation\r\n};\r\n"],"names":[],"mappings":";;;AAIA,IAAI,WAAW;AAEf,IAAI,SAAS,MAAM,SAAS,MAAM;AAElC,IAAI,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOZ,SAAS;AAAA,IACR;AAAA,IACA,CAAC,QAAQ,0FAAuF,CAAC,MAAM,CAAC,GAAG,MAAM;AAAA,IACjH;AAAA,EACA;AAAA,EACD,YAAY;AAAA,EACZ,QAAQ;AACT;AAEA,OAAO,SAAS,UAAU,QAAQ,UAAU,MAAM;AAAA;AAAA,EAEjD,WAAW;AAAA,EACX,UAAU;AAAA,IACT,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA,EAED,cAAc;AAAA,IACb;AAAA,IACA;AAAA,MACC,SAAS;AAAA,MACT,YAAY;AAAA,IACZ;AAAA,EACD;AAAA,EACD,YAAY;AAAA,IACX,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EAED,WAAW;AAAA,EACX,YAAY;AAAA,IACX,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EAED,UAAU;AAAA,EACV,QAAQ;AAAA,IACP,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EAED,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,eAAe;AAChB;"}