{"version":3,"file":"graphql.js","sources":["../../../src/prism/languages/graphql.js"],"sourcesContent":["import { languages, tokenize, withoutTokenizer } from '../core.js';\r\nimport { boolean } from '../utils/patterns.js';\r\n\r\nlanguages.graphql = {\r\n\t'comment': /#.*/,\r\n\t'description': {\r\n\t\tpattern: /(?:\"\"\"(?:[^\"]|\"(?!\"\"))*\"\"\"|\"(?:\\\\.|[^\\\\\\n\"])*\")(?=\\s*[a-z_])/gi,\r\n\t\tgreedy: true,\r\n\t\talias: 'string',\r\n\t\tinside: {\r\n\t\t\t'language-markdown': {\r\n\t\t\t\tpattern: /(\"(?!\")|\"\"\")[\\s\\S]+(?=\\1)/,\r\n\t\t\t\tlookbehind: true,\r\n\t\t\t\tinside: 'md'\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t'string': {\r\n\t\tpattern: /\"\"\"[\\s\\S]*?\"\"\"|\"(?:\\\\.|[^\\\\\\n\"])*\"/g,\r\n\t\tgreedy: true\r\n\t},\r\n\t'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\r\n\t'boolean': boolean,\r\n\t'variable': /\\$[a-z_]\\w*/i,\r\n\t'directive': {\r\n\t\tpattern: /@[a-z_]\\w*/i,\r\n\t\talias: 'function'\r\n\t},\r\n\t'attr-name': {\r\n\t\tpattern: /\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\\n\"])*\")*\\))?:)/gi,\r\n\t\tgreedy: true\r\n\t},\r\n\t'atom-input': {\r\n\t\tpattern: /\\b[A-Z]\\w*Input\\b/,\r\n\t\talias: 'class-name'\r\n\t},\r\n\t'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\r\n\t'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\r\n\t'class-name': {\r\n\t\tpattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\r\n\t\tlookbehind: true\r\n\t},\r\n\t'fragment': {\r\n\t\tpattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))(?!\\d)\\w+/,\r\n\t\tlookbehind: true,\r\n\t\talias: 'function'\r\n\t},\r\n\t'definition-mutation': {\r\n\t\tpattern: /(\\bmutation\\s+)(?!\\d)\\w+/,\r\n\t\tlookbehind: true,\r\n\t\talias: 'function'\r\n\t},\r\n\t'definition-query': {\r\n\t\tpattern: /(\\bquery\\s+)(?!\\d)\\w+/,\r\n\t\tlookbehind: true,\r\n\t\talias: 'function'\r\n\t},\r\n\t'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\r\n\t'operator': /[&|!=]|\\.{3}/,\r\n\t'property-query': /\\w+(?=\\s*\\()/,\r\n\t'object': /\\w+(?=\\s*\\{)/,\r\n\t'punctuation': /[()[\\]{},:!=]/,\r\n\t'property': /\\w+/,\r\n\t[tokenize](code, grammar) {\r\n\t\tvar tokens = withoutTokenizer(code, grammar);\r\n\r\n\t\t/**\r\n\t\t * get the graphql token stream that we want to customize\r\n\t\t *\r\n\t\t * @typedef {InstanceType<import(\"../core.js\")[\"Token\"]>} Token\r\n\t\t * @type {Token[]}\r\n\t\t */\r\n\t\tvar validTokens = tokens.filter(({type}) => type && type != 'comment' && type != 'scalar');\r\n\t\tvar l = validTokens.length;\r\n\t\tvar currentIndex = 0;\r\n\r\n\t\t/**\r\n\t\t * Returns whether the token relative to the current index has the given type.\r\n\t\t *\r\n\t\t * @param {readonly string[]} types\r\n\t\t * @returns {boolean}\r\n\t\t */\r\n\t\tvar isNotTokenType = types => {\r\n\t\t\tfor (var i = 0; i < types.length; i++) {\r\n\t\t\t\tif (currentIndex + i == l || validTokens[currentIndex + i].type != types[i]) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the index of the closing bracket to an opening bracket.\r\n\t\t *\r\n\t\t * It is assumed that `token[currentIndex - 1]` is an opening bracket.\r\n\t\t *\r\n\t\t * If no closing bracket could be found, `-1` will be returned.\r\n\t\t *\r\n\t\t * @param {string} open\r\n\t\t * @param {string} close\r\n\t\t * @returns {number | void}\r\n\t\t */\r\n\t\tvar findClosingBracket = (open, close) => {\r\n\t\t\tvar stackHeight = 1;\r\n\r\n\t\t\tfor (var i = currentIndex; i < l; i++) {\r\n\t\t\t\tvar token = validTokens[i];\r\n\t\t\t\tvar content = token.content;\r\n\r\n\t\t\t\tif (token.type == 'punctuation') {\r\n\t\t\t\t\tif (open == content) {\r\n\t\t\t\t\t\tstackHeight++;\r\n\t\t\t\t\t} else if (close == content && !--stackHeight) {\r\n\t\t\t\t\t\treturn i;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twhile (currentIndex < l) {\r\n\t\t\tvar startToken = validTokens[currentIndex++];\r\n\r\n\t\t\t// add special aliases for mutation tokens\r\n\t\t\tif (startToken.type == 'keyword' && startToken.content == 'mutation') {\r\n\t\t\t\t// any array of the names of all input variables (if any)\r\n\t\t\t\tvar inputVariables = [];\r\n\r\n\t\t\t\tif (!isNotTokenType(['definition-mutation', 'punctuation']) && validTokens[currentIndex + 1].content == '(') {\r\n\t\t\t\t\t// definition\r\n\r\n\t\t\t\t\tcurrentIndex += 2; // skip 'definition-mutation' and 'punctuation'\r\n\r\n\t\t\t\t\tvar definitionEnd = findClosingBracket(\"(\", \")\");\r\n\t\t\t\t\tif (!definitionEnd) continue;\r\n\r\n\t\t\t\t\t// find all input variables\r\n\t\t\t\t\tfor (; currentIndex < definitionEnd; currentIndex++) {\r\n\t\t\t\t\t\tvar t = validTokens[currentIndex];\r\n\t\t\t\t\t\tif (t.type == 'variable') {\r\n\t\t\t\t\t\t\tt.alias = 'variable-input';\r\n\t\t\t\t\t\t\tinputVariables.push(t.content);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrentIndex = definitionEnd + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!isNotTokenType(['punctuation', 'property-query']) && validTokens[currentIndex].content == '{') {\r\n\t\t\t\t\t// skip opening bracket\r\n\t\t\t\t\tvalidTokens[++currentIndex].alias = 'property-mutation';\r\n\r\n\t\t\t\t\tif (inputVariables[0]) {\r\n\t\t\t\t\t\tvar mutationEnd = findClosingBracket(\"{\", \"}\");\r\n\t\t\t\t\t\t// give references to input variables a special alias\r\n\t\t\t\t\t\tif (mutationEnd) for (var i = currentIndex; i < mutationEnd; i++) {\r\n\t\t\t\t\t\t\tvar varToken = validTokens[i];\r\n\t\t\t\t\t\t\tif (varToken.type == 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\r\n\t\t\t\t\t\t\t\tvarToken.alias = 'variable-input';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn tokens;\r\n\t}\r\n};\r\n"],"names":["i"],"mappings":"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"}