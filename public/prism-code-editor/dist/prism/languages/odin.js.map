{"version":3,"file":"odin.js","sources":["../../../src/prism/languages/odin.js"],"sourcesContent":["import { languages } from '../core.js';\r\n\r\nvar escapes = /\\\\(?:[\"'\\\\abefnrtv]|0[0-7]{2}|U[a-fA-F\\d]{6}|u[a-fA-F\\d]{4}|x[a-fA-F\\d]{2})/;\r\n\r\nlanguages.odin = {\r\n\t/**\r\n\t * The current implementation supports only 1 level of nesting.\r\n\t *\r\n\t * @author Michael Schmidt\r\n\t * @author edukisto\r\n\t */\r\n\t'comment': {\r\n\t\tpattern: /\\/\\/.*|#!.*|\\/\\*(?:[^/*]|\\/(?!\\*)|\\*(?!\\/)|\\/\\*(?:\\*(?!\\/)|[^*])*(?:\\*\\/|$))*(?:\\*\\/|$)/g,\r\n\t\tgreedy: true\r\n\t},\r\n\t/**\r\n\t * Should be found before strings because of '\"'\"- and '`'`-like sequences.\r\n\t */\r\n\t'char': {\r\n\t\tpattern: /'(?:\\\\(?:.|[0Uux][a-fA-F\\d]{1,6})|[^\\n'\\\\])'/g,\r\n\t\tgreedy: true,\r\n\t\tinside: {\r\n\t\t\t'symbol': escapes\r\n\t\t}\r\n\t},\r\n\r\n\t'string': [\r\n\t\t{\r\n\t\t\tpattern: /`[^`]*`/g,\r\n\t\t\tgreedy: true\r\n\t\t},\r\n\t\t{\r\n\t\t\tpattern: /\"(?:\\\\.|[^\\\\\\n\"])*\"/g,\r\n\t\t\tgreedy: true,\r\n\t\t\tinside: {\r\n\t\t\t\t'symbol': escapes\r\n\t\t\t}\r\n\t\t}\r\n\t],\r\n\r\n\t'directive': {\r\n\t\tpattern: /#\\w+/,\r\n\t\talias: 'property'\r\n\t},\r\n\r\n\t'number': /\\b0(?:b[01_]+|d[\\d_]+|h_*(?:(?:(?:[a-fA-F\\d]_*){8}){1,2}|(?:[a-fA-F\\d]_*){4})|o[0-7_]+|x[a-fA-F\\d_]+|z[\\dAB_ab]+)\\b|(?:\\b\\d+(?:\\.(?!\\.)\\d*)?|\\B\\.\\d+)(?:[Ee][+-]?\\d*)?[ijk]?(?!\\w)/,\r\n\r\n\t'discard': {\r\n\t\tpattern: /\\b_\\b/,\r\n\t\talias: 'keyword'\r\n\t},\r\n\r\n\t'procedure-definition': {\r\n\t\tpattern: /\\b\\w+(?=[ \\t]*(?::\\s*){2}proc\\b)/,\r\n\t\talias: 'function'\r\n\t},\r\n\r\n\t'keyword': /\\b(?:asm|auto_cast|bit_set|break|cas[et]|context|continue|defer|distinct|do|dynamic|else|enum|fallthrough|for|foreign|if|import|in|map|matrix|not_in|or_else|or_return|package|proc|return|struct|switch|transmute|typeid|union|using|when|where)\\b/,\r\n\r\n\t/**\r\n\t * false, nil, true can be used as procedure names. \"_\" and keywords can't.\r\n\t */\r\n\t'procedure-name': {\r\n\t\tpattern: /\\b\\w+(?=[ \\t]*\\()/,\r\n\t\talias: 'function'\r\n\t},\r\n\r\n\t'boolean': /\\b(?:false|true|nil)\\b/,\r\n\r\n\t'constant-parameter-sign': {\r\n\t\tpattern: /\\$/,\r\n\t\talias: 'important'\r\n\t},\r\n\r\n\t'undefined': {\r\n\t\tpattern: /---/,\r\n\t\talias: 'operator'\r\n\t},\r\n\r\n\t'arrow': {\r\n\t\tpattern: /->/,\r\n\t\talias: 'punctuation'\r\n\t},\r\n\r\n\t'operator': /--|\\+\\+|\\.\\.[<=]?|(?:&~|[~!=/*+-]|[%&|<>]{1,2})=?|[?^]/,\r\n\r\n\t'punctuation': /[()[\\]{}.,:;@]/\r\n};\r\n"],"names":[],"mappings":";AAEA,IAAI,UAAU;AAEd,UAAU,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOhB,WAAW;AAAA,IACV,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAID,QAAQ;AAAA,IACP,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,QAAQ;AAAA,MACP,UAAU;AAAA,IACV;AAAA,EACD;AAAA,EAED,UAAU;AAAA,IACT;AAAA,MACC,SAAS;AAAA,MACT,QAAQ;AAAA,IACR;AAAA,IACD;AAAA,MACC,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,QAAQ;AAAA,QACP,UAAU;AAAA,MACV;AAAA,IACD;AAAA,EACD;AAAA,EAED,aAAa;AAAA,IACZ,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EAED,UAAU;AAAA,EAEV,WAAW;AAAA,IACV,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EAED,wBAAwB;AAAA,IACvB,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EAED,WAAW;AAAA;AAAA;AAAA;AAAA,EAKX,kBAAkB;AAAA,IACjB,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EAED,WAAW;AAAA,EAEX,2BAA2B;AAAA,IAC1B,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EAED,aAAa;AAAA,IACZ,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EAED,SAAS;AAAA,IACR,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EAED,YAAY;AAAA,EAEZ,eAAe;AAChB;"}