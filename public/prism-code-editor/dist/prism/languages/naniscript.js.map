{"version":3,"file":"naniscript.js","sources":["../../../src/prism/languages/naniscript.js"],"sourcesContent":["import { languages, tokenize, withoutTokenizer } from '../core.js';\r\n\r\nvar expressionDef = /\\{[^\\n[\\]{}]*\\}/g;\r\n\r\nvar params = {\r\n\t'quoted-string': {\r\n\t\tpattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\r\n\t\talias: 'operator'\r\n\t},\r\n\t'command-param-id': {\r\n\t\tpattern: /(\\s)\\w+:/,\r\n\t\tlookbehind: true,\r\n\t\talias: 'property'\r\n\t},\r\n\t'command-param-value': [\r\n\t\t{\r\n\t\t\tpattern: expressionDef,\r\n\t\t\talias: 'selector',\r\n\t\t},\r\n\t\t{\r\n\t\t\tpattern: /([ \\t])\\S+/g,\r\n\t\t\tlookbehind: true,\r\n\t\t\tgreedy: true,\r\n\t\t\talias: 'operator',\r\n\t\t},\r\n\t\t{\r\n\t\t\tpattern: /\\S(?:.*\\S)?/,\r\n\t\t\talias: 'operator',\r\n\t\t}\r\n\t]\r\n};\r\n\r\n/**\r\n * @param {string} input\r\n * @returns {boolean}\r\n */\r\nvar isBadLine = input => {\r\n\tfor (var brackets = '[]{}', stack = [], s = 0, i = 0, l = input.length; i < l; ) {\r\n\t\tvar bracketsIndex = brackets.indexOf(input[i++]);\r\n\t\tif (bracketsIndex + 1) {\r\n\t\t\tif (bracketsIndex % 2) {\r\n\t\t\t\tif (stack[--s] != bracketsIndex) return true;\r\n\t\t\t} else stack[s++] = bracketsIndex + 1;\r\n\t\t}\r\n\t}\r\n\treturn s;\r\n}\r\n\r\nlanguages.nani = languages.naniscript = {\r\n\t// ; ...\r\n\t'comment': {\r\n\t\tpattern: /^([ \\t]*);.*/m,\r\n\t\tlookbehind: true,\r\n\t},\r\n\t// > ...\r\n\t// Define is a control line starting with '>' followed by a word, a space and a text.\r\n\t'define': {\r\n\t\tpattern: /^>.+/m,\r\n\t\talias: 'tag',\r\n\t\tinside: {\r\n\t\t\t'value': {\r\n\t\t\t\tpattern: /(^>\\w+[ \\t]+)(?!\\s)[^{}\\n]+/,\r\n\t\t\t\tlookbehind: true,\r\n\t\t\t\talias: 'operator'\r\n\t\t\t},\r\n\t\t\t'key': {\r\n\t\t\t\tpattern: /(^>)\\w+/,\r\n\t\t\t\tlookbehind: true,\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t// # ...\r\n\t'label': {\r\n\t\tpattern: /^([ \\t]*)#[ \\t]*\\w+[ \\t]*$/m,\r\n\t\tlookbehind: true,\r\n\t\talias: 'regex'\r\n\t},\r\n\t'command': {\r\n\t\tpattern: /^([ \\t]*)@\\w+(?=[ \\t]|$).*/m,\r\n\t\tlookbehind: true,\r\n\t\talias: 'function',\r\n\t\tinside: {\r\n\t\t\t'command-name': /^@\\w+/,\r\n\t\t\t'expression': {\r\n\t\t\t\tpattern: expressionDef,\r\n\t\t\t\tgreedy: true,\r\n\t\t\t\talias: 'selector'\r\n\t\t\t},\r\n\t\t\t'command-params': {\r\n\t\t\t\tpattern: /\\s*\\S[\\s\\S]*/,\r\n\t\t\t\tinside: params\r\n\t\t\t},\r\n\t\t}\r\n\t},\r\n\t// Generic is any line that doesn't start with operators: ;>#@\r\n\t'generic-text': {\r\n\t\tpattern: /(^[ \\t]*)[^#@>;\\s].*/m,\r\n\t\tlookbehind: true,\r\n\t\talias: 'punctuation',\r\n\t\tinside: {\r\n\t\t\t// \\{ ... \\} ... \\[ ... \\] ... \\\"\r\n\t\t\t'escaped-char': /\\\\[[\\]{}\"]/,\r\n\t\t\t'expression': {\r\n\t\t\t\tpattern: expressionDef,\r\n\t\t\t\tgreedy: true,\r\n\t\t\t\talias: 'selector'\r\n\t\t\t},\r\n\t\t\t'inline-command': {\r\n\t\t\t\tpattern: /\\[[ \\t]*\\w[^\\n[\\]]*\\]/g,\r\n\t\t\t\tgreedy: true,\r\n\t\t\t\talias: 'function',\r\n\t\t\t\tinside: {\r\n\t\t\t\t\t'start-stop-char': /[[\\]]/,\r\n\t\t\t\t\t'command-params': {\r\n\t\t\t\t\t\tpattern: /(^[ \\t]*\\w+)[\\s\\S]+/,\r\n\t\t\t\t\t\tlookbehind: true,\r\n\t\t\t\t\t\tinside: params\r\n\t\t\t\t\t},\r\n\t\t\t\t\t'command-param-name': {\r\n\t\t\t\t\t\tpattern: /\\w+/,\r\n\t\t\t\t\t\talias: 'name',\r\n\t\t\t\t\t},\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t[tokenize](code, grammar) {\r\n\t\tvar tokens = withoutTokenizer(code, grammar);\r\n\t\tvar position = 0;\r\n\t\tvar i = 0, l = tokens.length;\r\n\t\twhile (i < l) {\r\n\t\t\tvar token = tokens[i++];\r\n\t\t\tvar length = token.length;\r\n\t\t\tvar content;\r\n\r\n\t\t\tif (token.type == 'generic-text') {\r\n\t\t\t\tcontent = code.slice(position, position + length);\r\n\t\t\t\tif (isBadLine(content)) {\r\n\t\t\t\t\ttoken.type = 'bad-line';\r\n\t\t\t\t\ttoken.content = content;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tposition += length;\r\n\t\t}\r\n\t\treturn tokens;\r\n\t}\r\n};\r\n"],"names":[],"mappings":"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"}