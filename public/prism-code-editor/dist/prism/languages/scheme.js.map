{"version":3,"file":"scheme.js","sources":["../../../src/prism/languages/scheme.js"],"sourcesContent":["import { languages } from '../core.js';\r\n\r\n/**\r\n * Given a topologically sorted BNF grammar, this will return the RegExp source of last rule of the grammar.\r\n *\r\n * @param {Record<string, string>} grammar\r\n */\r\nvar SortedBNF = grammar => {\r\n\tfor (var key in grammar) {\r\n\t\tgrammar[key] = grammar[key].replace(/<[\\w ]+>/g, key => `(?:${grammar[key]})`);\r\n\t}\r\n\t// return the last item\r\n\treturn RegExp(grammar[key], 'i');\r\n}\r\n\r\nlanguages.scheme = {\r\n\t// this supports \"normal\" single-line comments:\r\n\t//   ; comment\r\n\t// and (potentially nested) multiline comments:\r\n\t//   #| comment #| nested |# still comment |#\r\n\t// (only 1 level of nesting is supported)\r\n\t'comment': /;.*|#;\\s*(?:\\((?:[^()]|\\([^)]*\\))*\\)|\\[(?:[^[\\]]|\\[[^\\]]*\\])*\\])|#\\|(?:[^#|]|#(?!\\|)|\\|(?!#)|#\\|(?:[^#|]|#(?!\\|)|\\|(?!#))*\\|#)*\\|#/,\r\n\t'string': {\r\n\t\tpattern: /\"(?:\\\\.|[^\\\\\"])*\"/g,\r\n\t\tgreedy: true\r\n\t},\r\n\t'symbol': {\r\n\t\tpattern: /'[^()[\\]#'\\s]+/g,\r\n\t\tgreedy: true\r\n\t},\r\n\t'char': {\r\n\t\tpattern: /#\\\\(?:[ux][a-fA-F\\d]+\\b|[-a-zA-Z]+\\b|[\\ud800-\\udbff][\\udc00-\\udfff]|\\S)/g,\r\n\t\tgreedy: true\r\n\t},\r\n\t'lambda-parameter': [\r\n\t\t// https://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html#SEC30\r\n\t\t{\r\n\t\t\tpattern: /((?:^|[^'`#])[([]lambda\\s+)(?:[^\\s()[\\]'|]+|\\|(?:\\\\.|[^\\\\|])*\\|)/,\r\n\t\t\tlookbehind: true\r\n\t\t},\r\n\t\t{\r\n\t\t\tpattern: /((?:^|[^'`#])[([]lambda\\s+[([])[^()[\\]']+/,\r\n\t\t\tlookbehind: true\r\n\t\t}\r\n\t],\r\n\t'keyword': {\r\n\t\tpattern: /((?:^|[^'`#])[([])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\\*)?|let\\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?![^()[\\]\\s])/,\r\n\t\tlookbehind: true\r\n\t},\r\n\t'builtin': {\r\n\t\t// all functions of the base library of R7RS plus some of built-ins of R5Rs\r\n\t\tpattern: /((?:^|[^'`#])[([])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\\?|boolean=?\\?|bytevector(?:-append|-copy!?|-length|-u8-ref|-u8-set!|\\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\\?|\\?|<\\?|<=\\?|=\\?|>\\?|>=\\?)|close-(?:input-port|output-port|port)|complex\\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\\??|eq\\?|equal\\?|eqv\\?|error|error-object(?:-irritants|-message|\\?)|eval|even\\?|exact(?:-integer-sqrt|-integer\\?|\\?)?|expt|features|file-error\\?|floor(?:-quotient|-remainder|\\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\\??|input-port(?:-open\\?|\\?)|integer(?:->char|\\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|mem[qv]|min|modulo|negative\\?|newline|not|null\\?|number(?:->string|\\?)|numerator|odd\\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\\?|\\?)|pair\\?|peek-char|peek-u8|port\\?|positive\\?|procedure\\?|quotient|raise|raise-continuable|rational\\?|rationalize|read-(?:bytevector|bytevector!|char|error\\?|line|string|u8)|real\\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy!?|-fill!|-for-each|-length|-map|-ref|-set!|\\?|<\\?|<=\\?|=\\?|>\\?|>=\\?)?|substring|symbol(?:->string|\\?|=\\?)|syntax-error|textual-port\\?|truncate(?:-quotient|-remainder|\\/)?|u8-ready\\?|utf8->string|values|vector(?:->list|->string|-append|-copy!?|-fill!|-for-each|-length|-map|-ref|-set!|\\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\\?)(?![^()[\\]\\s])/,\r\n\t\tlookbehind: true\r\n\t},\r\n\t'operator': {\r\n\t\tpattern: /((?:^|[^'`#])[([])(?:[%/*+-]|[<>]=?|=>?)(?![^()[\\]\\s])/,\r\n\t\tlookbehind: true\r\n\t},\r\n\t'number': {\r\n\t\t// The number pattern from [the R7RS spec](https://small.r7rs.org/attachment/r7rs.pdf).\r\n\t\t//\r\n\t\t// <number>      := <num 2>|<num 8>|<num 10>|<num 16>\r\n\t\t// <num R>       := <prefix R><complex R>\r\n\t\t// <complex R>   := <real R>(?:@<real R>|<imaginary R>)?|<imaginary R>\r\n\t\t// <imaginary R> := [+-](?:<ureal R>|(?:inf|nan)\\.0)?i\r\n\t\t// <real R>      := [+-]?<ureal R>|[+-](?:inf|nan)\\.0\r\n\t\t// <ureal R>     := <uint R>(?:\\/<uint R>)?\r\n\t\t//                | <decimal R>\r\n\t\t//\r\n\t\t// <decimal 10>  := (?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?\r\n\t\t// <uint R>      := <digit R>+\r\n\t\t// <prefix R>    := <radix R>(?:#[ei])?|(?:#[ei])?<radix R>\r\n\t\t// <radix 2>     := #b\r\n\t\t// <radix 8>     := #o\r\n\t\t// <radix 10>    := (?:#d)?\r\n\t\t// <radix 16>    := #x\r\n\t\t// <digit 2>     := [01]\r\n\t\t// <digit 8>     := [0-7]\r\n\t\t// <digit 10>    := \\d\r\n\t\t// <digit 16>    := [a-f\\d]\r\n\t\t//\r\n\t\t// The problem with this grammar is that the resulting regex is way to complex, so we simplify by grouping all\r\n\t\t// non-decimal bases together. This results in a decimal (dec) and combined binary, octal, and hexadecimal (box)\r\n\t\t// pattern:\r\n\t\tpattern: SortedBNF({\r\n\t\t\t'<ureal dec>': /\\d+(?:\\/\\d+)|(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[esfdl][+-]?\\d+)?/.source,\r\n\t\t\t'<real dec>': /[+-]?<ureal dec>|[+-](?:inf|nan)\\.0/.source,\r\n\t\t\t'<imaginary dec>': /[+-](?:<ureal dec>|(?:inf|nan)\\.0)?i/.source,\r\n\t\t\t'<complex dec>': /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/.source,\r\n\t\t\t'<num dec>': /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,\r\n\r\n\t\t\t'<ureal box>': /[a-f\\d]+(?:\\/[a-f\\d]+)?/.source,\r\n\t\t\t'<real box>': /[+-]?<ureal box>|[+-](?:inf|nan)\\.0/.source,\r\n\t\t\t'<imaginary box>': /[+-](?:<ureal box>|(?:inf|nan)\\.0)?i/.source,\r\n\t\t\t'<complex box>': /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/.source,\r\n\t\t\t'<num box>': /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/.source,\r\n\r\n\t\t\t'<number>': /(^|[()[\\]\\s])(?:<num dec>|<num box>)(?![^()[\\]\\s])/.source,\r\n\t\t}),\r\n\t\tlookbehind: true\r\n\t},\r\n\t'boolean': {\r\n\t\tpattern: /(^|[()[\\]\\s])#(?:[ft]|false|true)(?![^()[\\]\\s])/,\r\n\t\tlookbehind: true\r\n\t},\r\n\t'function': {\r\n\t\tpattern: /((?:^|[^'`#])[([])(?:[^|()[\\]'\\s]+|\\|(?:\\\\.|[^\\\\|])*\\|)(?![^()[\\]\\s])/,\r\n\t\tlookbehind: true\r\n\t},\r\n\t'identifier': {\r\n\t\tpattern: /(^|[()[\\]\\s])\\|(?:\\\\.|[^\\\\|])*\\|(?![^()[\\]\\s])/g,\r\n\t\tlookbehind: true,\r\n\t\tgreedy: true\r\n\t},\r\n\t'punctuation': /[()[\\]']/\r\n};\r\n"],"names":["key"],"mappings":";AAOA,IAAI,YAAY,aAAW;AAC1B,WAAS,OAAO,SAAS;AACxB,YAAQ,GAAG,IAAI,QAAQ,GAAG,EAAE,QAAQ,aAAa,CAAAA,SAAO,MAAM,QAAQA,IAAG,CAAC,GAAG;AAAA,EAC7E;AAED,SAAO,OAAO,QAAQ,GAAG,GAAG,GAAG;AAChC;AAEA,UAAU,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMlB,WAAW;AAAA,EACX,UAAU;AAAA,IACT,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA,EACD,UAAU;AAAA,IACT,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA,EACD,QAAQ;AAAA,IACP,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA,EACD,oBAAoB;AAAA;AAAA,IAEnB;AAAA,MACC,SAAS;AAAA,MACT,YAAY;AAAA,IACZ;AAAA,IACD;AAAA,MACC,SAAS;AAAA,MACT,YAAY;AAAA,IACZ;AAAA,EACD;AAAA,EACD,WAAW;AAAA,IACV,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EACD,WAAW;AAAA;AAAA,IAEV,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EACD,YAAY;AAAA,IACX,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EACD,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA0BT,SAAS,UAAU;AAAA,MAClB,eAAe;AAAA,MACf,cAAc;AAAA,MACd,mBAAmB;AAAA,MACnB,iBAAiB;AAAA,MACjB,aAAa;AAAA,MAEb,eAAe;AAAA,MACf,cAAc;AAAA,MACd,mBAAmB;AAAA,MACnB,iBAAiB;AAAA,MACjB,aAAa;AAAA,MAEb,YAAY;AAAA,IACf,CAAG;AAAA,IACD,YAAY;AAAA,EACZ;AAAA,EACD,WAAW;AAAA,IACV,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EACD,YAAY;AAAA,IACX,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EACD,cAAc;AAAA,IACb,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,QAAQ;AAAA,EACR;AAAA,EACD,eAAe;AAChB;"}