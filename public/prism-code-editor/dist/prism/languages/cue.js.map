{"version":3,"file":"cue.js","sources":["../../../src/prism/languages/cue.js"],"sourcesContent":["import { languages } from '../core.js';\r\nimport { re } from '../utils/shared.js';\r\n\r\n// https://cuelang.org/docs/references/spec/\r\n\r\n// eslint-disable-next-line regexp/strict\r\nvar stringEscape = /\\\\(?:(?!\\2)|\\2(?:[^()\\n]|\\([^()]*\\)))/.source;\r\nvar stringLiteral = re(`(^|[^#\"'\\\\\\\\])(#*)(?:\"\"\"(?:[^\\\\\\\\\"]|\"(?!\"\"\\\\2)|<0>)*\"\"\"|'''(?:[^\\\\\\\\']|'(?!''\\\\2)|<0>)*'''|\"(?:[^\\\\\\\\\\n\"]|\"(?!\\\\2)|<0>)*\"|'(?:[^\\\\\\\\\\n']|'(?!\\\\2)|<0>)*')(?![\"'])\\\\2`, [stringEscape], 'g');\r\n\r\nvar expression = {\r\n\tpattern: /[\\s\\S]+/\r\n}\r\n\r\nexpression.inside = languages.cue = {\r\n\t'comment': /\\/\\/.*/,\r\n\t'string-literal': {\r\n\t\tpattern: stringLiteral,\r\n\t\tlookbehind: true,\r\n\t\tgreedy: true,\r\n\t\tinside: {\r\n\t\t\t// I'm using dirty hack here. We have to know the number hashes at the start of the string somehow,\r\n\t\t\t// but we can't look back. So instead, we will use a lookahead, go to the end of the string, and\r\n\t\t\t// capture the hashes at the end of the string.\r\n\t\t\t'escape': {\r\n\t\t\t\tpattern: /(?=[\\s\\S]*[\"'](#*)$)\\\\\\1(?:U[a-fA-F\\d]{1,8}|u[a-fA-F\\d]{1,4}|x[a-fA-F\\d]{1,2}|\\d{2,3}|[^(])/g,\r\n\t\t\t\tgreedy: true,\r\n\t\t\t\talias: 'string'\r\n\t\t\t},\r\n\t\t\t'interpolation': {\r\n\t\t\t\tpattern: /(?=[\\s\\S]*[\"'](#*)$)\\\\\\1\\([^()]*\\)/g,\r\n\t\t\t\tgreedy: true,\r\n\t\t\t\tinside: {\r\n\t\t\t\t\t'punctuation': /^\\\\#*\\(|\\)$/,\r\n\t\t\t\t\t'expression': expression\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t'string': /[\\s\\S]+/\r\n\t\t}\r\n\t},\r\n\r\n\t'keyword': {\r\n\t\tpattern: /(^|[^$\\w])(?:for|if|import|in|let|null|package)(?![$\\w])/,\r\n\t\tlookbehind: true\r\n\t},\r\n\t'boolean': {\r\n\t\tpattern: /(^|[^$\\w])(?:false|true)(?![$\\w])/,\r\n\t\tlookbehind: true\r\n\t},\r\n\t'builtin': {\r\n\t\tpattern: /(^|[^$\\w])(?:bool|bytes|float(?:32|64)?|u?int(?:8|16|32|64|128)?|number|rune|string)(?![$\\w])/,\r\n\t\tlookbehind: true\r\n\t},\r\n\r\n\t'attribute': {\r\n\t\tpattern: /@[$\\w]+(?=\\s*\\()/,\r\n\t\talias: 'function'\r\n\t},\r\n\t'function': {\r\n\t\tpattern: /(^|[^$\\w])[a-z_$][$\\w]*(?=\\s*\\()/i,\r\n\t\tlookbehind: true\r\n\t},\r\n\r\n\t'number': {\r\n\t\tpattern: /(^|[^$\\w.])(?:0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|0[xX][a-fA-F\\d]+(?:_[a-fA-F\\d]+)*|(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[eE][+-]?\\d+(?:_\\d+)*)?(?:[KMGTP]i?)?)(?![$\\w])/,\r\n\t\tlookbehind: true\r\n\t},\r\n\r\n\t'operator': /\\.{3}|_\\|_|&&?|\\|\\|?|[!=]~|[<>!=]=?|[?/*+-]/,\r\n\t'punctuation': /[()[\\]{}.,:]/\r\n};\r\n"],"names":[],"mappings":";;AAMA,IAAI,eAAe;AACnB,IAAI,gBAAgB,GAAG;AAAA;AAAA,iCAAwK,CAAC,YAAY,GAAG,GAAG;AAElN,IAAI,aAAa;AAAA,EAChB,SAAS;AACV;AAEA,WAAW,SAAS,UAAU,MAAM;AAAA,EACnC,WAAW;AAAA,EACX,kBAAkB;AAAA,IACjB,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA;AAAA;AAAA,MAIP,UAAU;AAAA,QACT,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,OAAO;AAAA,MACP;AAAA,MACD,iBAAiB;AAAA,QAChB,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,QAAQ;AAAA,UACP,eAAe;AAAA,UACf,cAAc;AAAA,QACd;AAAA,MACD;AAAA,MACD,UAAU;AAAA,IACV;AAAA,EACD;AAAA,EAED,WAAW;AAAA,IACV,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EACD,WAAW;AAAA,IACV,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EACD,WAAW;AAAA,IACV,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EAED,aAAa;AAAA,IACZ,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EACD,YAAY;AAAA,IACX,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EAED,UAAU;AAAA,IACT,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EAED,YAAY;AAAA,EACZ,eAAe;AAChB;"}