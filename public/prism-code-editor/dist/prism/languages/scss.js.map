{"version":3,"file":"scss.js","sources":["../../../src/prism/languages/scss.js"],"sourcesContent":["import { languages, rest } from '../core.js';\r\nimport { extend, insertBefore } from '../utils/language.js';\r\nimport { boolean, clikeComment } from '../utils/patterns.js';\r\nimport './css.js';\r\n\r\nvar scss = languages.scss = extend('css', {\r\n\t'comment': clikeComment(),\r\n\t'atrule': {\r\n\t\tpattern: /@[\\w-](?:\\([^()]+\\)|[^()\\s]|\\s+(?!\\s))*?(?=\\s+[{;])/,\r\n\t\tinside: {\r\n\t\t\t'rule': /@[\\w-]+/,\r\n\t\t\t[rest]: 'scss'\r\n\t\t}\r\n\t},\r\n\t// url, compassified\r\n\t'url': /(?:[-a-z]+-)?url(?=\\()/i,\r\n\t// CSS selector regex is not appropriate for Sass\r\n\t// since there can be lot more things (var, @ directive, nesting..)\r\n\t// a selector must start at the end of a property or after a brace (end of other rules or nesting)\r\n\t// it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\r\n\t// the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\r\n\t// can \"pass\" as a selector- e.g: proper#{$erty})\r\n\t// this one was hard to do, so please be careful if you edit this one :)\r\n\t'selector': {\r\n\t\t// Initial look-ahead is used to prevent matching of blank selectors\r\n\t\tpattern: /(?!\\s)[^@;(){}]?(?:[^@;(){}\\s]|\\s+(?!\\s)|#\\{\\$[-\\w]+\\})+(?=\\s*\\{(?:\\}|\\s|[^}][^:{}]*[:{][^}]))/,\r\n\t\tinside: {\r\n\t\t\t'parent': {\r\n\t\t\t\tpattern: /&/,\r\n\t\t\t\talias: 'important'\r\n\t\t\t},\r\n\t\t\t'placeholder': /%[-\\w]+/,\r\n\t\t\t'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\r\n\t\t}\r\n\t},\r\n\t'property': {\r\n\t\tpattern: /(?:[-\\w]|\\$[-\\w]|#\\{\\$[-\\w]+\\})+(?=\\s*:)/,\r\n\t\tinside: {\r\n\t\t\t'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\r\n\t\t}\r\n\t}\r\n});\r\n\r\ninsertBefore(scss, 'atrule', {\r\n\t'keyword': [\r\n\t\t/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\\b/i,\r\n\t\t{\r\n\t\t\tpattern: /( )(?:from|through)(?= )/,\r\n\t\t\tlookbehind: true\r\n\t\t}\r\n\t]\r\n});\r\n\r\ninsertBefore(scss, 'important', {\r\n\t// var and interpolated vars\r\n\t'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\r\n});\r\n\r\ninsertBefore(scss, 'function', {\r\n\t'module-modifier': {\r\n\t\tpattern: /\\b(?:as|hide|show|with)\\b/i,\r\n\t\talias: 'keyword'\r\n\t},\r\n\t'placeholder': {\r\n\t\tpattern: /%[-\\w]+/,\r\n\t\talias: 'selector'\r\n\t},\r\n\t'statement': {\r\n\t\tpattern: /\\B!(?:default|optional)\\b/i,\r\n\t\talias: 'keyword'\r\n\t},\r\n\t'boolean': boolean,\r\n\t'null': {\r\n\t\tpattern: /\\bnull\\b/,\r\n\t\talias: 'keyword'\r\n\t},\r\n\t'operator': {\r\n\t\tpattern: /(\\s)(?:[%/*+-]|[!=]=|[<>]=?|and|not|or)(?!\\S)/,\r\n\t\tlookbehind: true\r\n\t}\r\n});\r\n"],"names":[],"mappings":";;;;AAKA,IAAI,OAAO,UAAU,OAAO,OAAO,OAAO;AAAA,EACzC,WAAW,aAAc;AAAA,EACzB,UAAU;AAAA,IACT,SAAS;AAAA,IACT,QAAQ;AAAA,MACP,QAAQ;AAAA,MACR,CAAC,IAAI,GAAG;AAAA,IACR;AAAA,EACD;AAAA;AAAA,EAED,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQP,YAAY;AAAA;AAAA,IAEX,SAAS;AAAA,IACT,QAAQ;AAAA,MACP,UAAU;AAAA,QACT,SAAS;AAAA,QACT,OAAO;AAAA,MACP;AAAA,MACD,eAAe;AAAA,MACf,YAAY;AAAA,IACZ;AAAA,EACD;AAAA,EACD,YAAY;AAAA,IACX,SAAS;AAAA,IACT,QAAQ;AAAA,MACP,YAAY;AAAA,IACZ;AAAA,EACD;AACF,CAAC;AAED,aAAa,MAAM,UAAU;AAAA,EAC5B,WAAW;AAAA,IACV;AAAA,IACA;AAAA,MACC,SAAS;AAAA,MACT,YAAY;AAAA,IACZ;AAAA,EACD;AACF,CAAC;AAED,aAAa,MAAM,aAAa;AAAA;AAAA,EAE/B,YAAY;AACb,CAAC;AAED,aAAa,MAAM,YAAY;AAAA,EAC9B,mBAAmB;AAAA,IAClB,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EACD,eAAe;AAAA,IACd,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EACD,aAAa;AAAA,IACZ,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EACD,WAAW;AAAA,EACX,QAAQ;AAAA,IACP,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EACD,YAAY;AAAA,IACX,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AACF,CAAC;"}